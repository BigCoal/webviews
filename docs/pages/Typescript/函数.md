### 函数

Functions are the basic building block of any application, whether they’re local functions, imported from another module, or methods on a class. They’re also values, and just like other values, TypeScript has many ways to describe how functions can be called. Let’s learn about how to write types that describe functions.

函数是任何应用程序的基本构建块，无论它们是从另一个模块导入的本地函数，还是类上的方法。它们也是值，就像其他值一样，TypeScript 有许多方法来描述函数的调用方式。让我们学习如何编写描述函数的类型。

[](#function-type-expressions)Function Type Expressions

函数类型表达式


------------------------------------------------------------------

The simplest way to describe a function is with a _function type expression_. These types are syntactically similar to arrow functions:

描述函数最简单的方法是使用函数类型表达式。这些类型在语法上类似于箭头函数:

``` ts

function greeter(fn: (a: string) => void) {

 fn("Hello, World");

}

function printToConsole(s: string) {

 console.log(s);

}

greeter(printToConsole);

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1XagFMMALkVwENiBnKVGMZASkQF4A+RANzhgBNGBvALAAoRIgK4ARAAl0AG1lwANIgDqcVLO4T6AbmEBfYcNCRYCRAAcaYKABU4AYQQU4s9LgqVqtBokEjECGdXdAA6BWQPXQMjITRMbDwrWjtHYLddIA)

函数 greeter (fn: (a: string) = > void){ fn (“ Hello，World”) ; } 函数 printToConsole (s: string){ console.log (s) ; } greeter (printToConsole) ; Try


```

The syntax `(a: string) => void` means “a function with one parameter, named `a`, of type string, that doesn’t have a return value”. Just like with function declarations, if a parameter type isn’t specified, it’s implicitly `any`.

语法 (a: string) = > void 表示 “具有一个类型为 string 的参数 (名为 a) 的函数，该函数没有返回值”。就像函数声明一样，如果没有指定参数类型，它就是隐式的。

> Note that the parameter name is **required**. The function type `(string) => void` means “a function with a parameter named `string` of type `any`“!
> 
> 请注意，参数名是必需的。函数类型 (string) = > void 表示 “一个具有类型为 any 的参数 string 的函数”！

Of course, we can use a type alias to name a function type:

当然，我们可以使用类型别名来命名函数类型:

``` ts

type GreetFunction = (a: string) => void;

function greeter(fn: GreetFunction) {

 // ...

}

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwBiBXAdgY2ASwPbpQC8UAFAIYBcUAzsHDugOYCUxAfFAG544AmAbgCwAKABmGbPkJMESCHFJj01eIhSTcBNgG9RUKAHpDUAHTnRAXyA)

函数 greeter (fn: GreetFunction){///... } Try


```

[](#call-signatures)Call Signatures

呼叫签名


-------------------------------------------

In JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesn’t allow for declaring properties. If we want to describe something callable with properties, we can write a _call signature_ in an object type:

在 JavaScript 中，函数除了可调用之外，还可以具有属性。但是，函数类型表达式语法不允许声明属性。如果我们想用属性来描述可调用的东西，我们可以用对象类型来写一个调用签名:

``` ts

type DescribableFunction = {

 description: string;

 (someArg: number): boolean;

};

function doSomething(fn: DescribableFunction) {

 console.log(fn.description + " returned " + fn(6));

}

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAIhDOBjATgSwEYEN0BsIDEBXAO0WFQHtioBeKAbwFgAoKKAEwRVTHKoC4o8YGmIBzANws2ACngUAthACCyMYOKEF6CMgCUg9BQp5MxKcwC+FgGYkylauwoBlRRGAALVOJk3ignBIaFi4BPZ8xHoM0lCIVPJ4AHQ4FGJ+xEmcwTyRUADUUABEUMgehMjEEOzFBVD+MgBsenoWlkA)

{ description: string; (someArg: number) : boolean; } ; function doSomething (fn: describe bablefunction){ console.log (fn. description +”return”+ fn (6)) ; } Try


```

Note that the syntax is slightly different compared to a function type expression - use `:` between the parameter list and the return type rather than `=>`.

注意，与函数类型 expression-use: 在参数列表和返回类型之间的语法稍有不同，而不是 = > 。

[](#construct-signatures)Construct Signatures

构造签名


-----------------------------------------------------

JavaScript functions can also be invoked with the `new` operator. TypeScript refers to these as _constructors_ because they usually create a new object. You can write a _construct signature_ by adding the `new` keyword in front of a call signature:

函数也可以用新的操作符来调用。引用这些作为构造函数，因为它们通常创建一个新对象。你可以通过在调用签名前面添加 new 关键字来写一个构造签名:

``` ts

type SomeConstructor = {

 new (s: string): SomeObject;

};

function fn(ctor: SomeConstructor) {

 return new ctor("hello");

}

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgeQEYCsIGNhQLxQCGAdiANwCwAUAPQ1QC0TWArsEw9aJLIhAMJxiAZ2AAnFjjhj8UAN7UoUYhADuUABTCAXFFFiAlsQDmASl3wkaTDkpUAvnYBmLYjgNCoT4hqliLfIIi4pLA0qbyilBiEMAsYsTKalB+GgBEABYQADbZcGmmdvZAA)

Tstype somceconstruct = { new (s: string) : SomeObject; } ; function fn (ctor: somceconstructor){ return new ctor (“ hello”) ; } Try


```

Some objects, like JavaScript’s `Date` object, can be called with or without `new`. You can combine call and construct signatures in the same type arbitrarily:

有些对象，比如 JavaScript 的 Date 对象，可以使用或不使用 new 来调用。您可以任意组合调用和构造同一类型的签名:

``` ts

interface CallOrConstruct {

 new (s: string): Date;

 (n?: number): number;

}

[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMJwDYYPJVQexAGcwoBXBMZAbwFgAoZZECAd2QAoiAuZEqUAHMAlLwAicSAG4GTDiAD8vEGQC2AI2ijmazVBn0AvkA)

接口 CallOrConstruct {new (s: string) : Date; (n? : number) : number; } Try


```

[](#generic-functions)Generic Functions

通用函数


-----------------------------------------------

It’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way. Let’s consider for a moment a function that returns the first element of an array:

通常编写一个函数，其中输入的类型与输出的类型相关，或者两个输入的类型以某种方式相关。让我们暂时考虑一个返回数组第一个元素的函数:

``` ts

function firstElement(arr: any[]) {

 return arr[0];

}

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAFAIaqoBci5YAngNoC6AlIgN4CwAUIolR4oIVEkqomABhYBuPgF8gA)

Tsfunction firstElement (arr: any []){ return arr [0] ; } Try


```

This function does its job, but unfortunately has the return type `any`. It’d be better if the function returned the type of the array element.

这个函数完成它的工作，但不幸的是返回类型为 any。如果函数返回数组元素的类型会更好。

In TypeScript, _generics_ are used when we want to describe a correspondence between two values. We do this by declaring a _type parameter_ in the function signature:

在 TypeScript 中，泛型用于描述两个值之间的对应关系。我们通过在函数签名中声明一个类型参数来实现:

``` ts

function firstElement<Type>(arr: Type[]): Type | undefined {

 return arr[0];

}

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAPACoCeADngHwAUAhqqgFyJW0DaAugJQcueRAB9E4ACZ4UYPJMQBvALAAoRIlR4oIVEhapuABl4BuNQF8gA)

Tsfunction firstElement < Type > (arr: Type []) : Type | undefined { return arr [0] ; } Try


```

By adding a type parameter `Type` to this function and using it in two places, we’ve created a link between the input of the function (the array) and the output (the return value). Now when we call it, a more specific type comes out:

通过向这个函数添加类型参数 Type 并在两个地方使用它，我们在函数的输入 (数组) 和输出 (返回值) 之间创建了一个链接。现在，当我们称之为，一个更具体的类型出现了:

``` ts

// s is of type 'string'

const s = firstElement(["a", "b", "c"]);

// n is of type 'number'

const n = firstElement([1, 2, 3]);

// u is of type undefined

const u = firstElement([]);

[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVKxgGcMBRCEAWxFQwB4AVATwAcQA+AClhgC55mbANoBdAJT9BCAD7w0oRFlQhgAbgCwAKAD02+AFpDYZBkP6tu+EXhZrORPAysEAchIwlAcxdaweElbwALwExGQU1LScQgBEUDEANPAxAEaJyWAx4ho6evi28PaOzvAuqMiUKSAwPpp+qAH4IYph5FQ0GNEAjEkATEkAzNkWesg2dg5ObHKoCkoqvv4YcsGhJG2RnaJiqkA)

Ts/s 类型为‘ string’const s = firstElement ([“a”，“ b”，“ c”]) ;//n 类型为‘ number’const n = firstElement ([1,2,3]) ;//u 类型为 undefinedconst u = firstElement ([]) ; Try


```

### [](#inference)Inference

推论

Note that we didn’t have to specify `Type` in this sample. The type was _inferred_ - chosen automatically - by TypeScript.

注意，我们不必在这个示例中指定 Type。类型是由打字稿自动推断选择的。

We can use multiple type parameters as well. For example, a standalone version of `map` would look like this:

我们也可以使用多个类型参数，例如，一个独立版本的 map 看起来像这样:

``` ts

function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {

 return arr.map(func);

}

// Parameter 'n' is of type 'string'

// 'parsed' is of type 'number[]'

const parsed = map(["1", "2", "3"], (n) => parseInt(n));

[Try](https://www.typescriptlang.org/play/#code/PTAEAcCcFMBdYJbUgWgQcwHYHsYFgAoAMwFdMBjRbTUAWwENwAeASU3BNgBpQB5TjrAB8ACnqRIALlBtBAbQC6PUhWljI6abM4BKUAF4hfAbun9Y8haADehUKBiwSkGuMgA6BuBEryOgNyEAL6EhCCgAAri9LRwyKAA5JgJoAgAzqDYRKCwAJ7g0IlpsJAImOgJYWAJ4OJp0AAmKemZ2XkFiZgktABGyIqVBOTUxRB1jQZ0jCJyAEQAjLM8swBMS6CzAMyzSqAimHqGY5D1bLD7OgFAA)

Tsfunction map  (arr: Input [] ，func: (arg: Input) = > Output) : Output []{ return arr.map (func) ; }//Parameter’n’类型为‘ string’//‘ parsed’类型为‘ number []‘ const parsed = map ([“1”，“2”，“3”] ，(n) = > parseInt (n) ;


```

Note that in this example, TypeScript could infer both the type of the `Input` type parameter (from the given `string` array), as well as the `Output` type parameter based on the return value of the function expression (`number`).

注意，在这个示例中，TypeScript 可以根据函数表达式的返回值 (数字) 推断出 Input 类型参数的类型 (来自给定的字符串数组) ，以及 Output 类型参数。

### [](#constraints)Constraints

约束

We’ve written some generic functions that can work on _any_ kind of value. Sometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a _constraint_ to limit the kinds of types that a type parameter can accept.

我们已经编写了一些通用函数，它们可以处理任何类型的值。有时候，我们希望关联两个值，但是只能对值的某个子集进行操作。在这种情况下，我们可以使用约束来限制类型参数可以接受的类型种类。

Let’s write a function that returns the longer of two values. To do this, we need a `length` property that’s a number. We _constrain_ the type parameter to that type by writing an `extends` clause:

让我们编写一个函数，返回两个值中较长的一个。要做到这一点，我们需要一个长度属性，它是一个数字。我们通过写一个 extends 子句将类型参数约束为该类型:

``` ts

function longest<Type extends { length: number }>(a: Type, b: Type) {

 if (a.length >= b.length) {

 return a;

 } else {

 return b;

 }

}

// longerArray is of type 'number[]'

const longerArray = longest([1, 2], [1, 2, 3]);

// longerString is of type 'alice' | 'bob'

const longerString = longest("alice", "bob");

// Error! Numbers don't have a 'length' property

const notOK = longest(10, 100);

Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.2345Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdG00BYAKADMBXAOwGMAXASzitABtmBzSROgHgBUAngAdIoSAA86kKgBNEoAN5sZHOgAtUVCgFsARjFABfAHwAKAIaohogDSg91kZACUS0qFAMyoSwDpWVQ1QEwBeBwCg9TdFD09QaEg6CmgWCwBuOKNxVkQxWJJ4hKSUlj1MwuNSI1JSEDZOGABBWAtBLwU4HzpnUABybX0YAG0AXT7SGmYeBqouaBboNtBw9jnuOjNhgEZ7NFH7Hb37DFGXCvq1+YBlOmgGOY7QLtAe0X6LVgYaSD7QAB9+no4HoJiQplQZlcYLd7o9Vo0eGYAESfb6QZH2ZHAvTI851MAAUVgCAAhKAAHK6AxIUCyZh9OigdQWABuYgs-UCcw0f2E8FE0B6k2mTKocDoAHkANIrWZcJHbAAM9mVSvOQA)

Tsfunction longest  (a: Type，b: Type){ if (a.length > = b.length){ return a; } else { return b; }/longerArray 类型为‘ number []‘ const longerArray = longest ([1,2] ，[1,2,3]) ;//longerString 类型为‘ alice’| ‘ bob‘ const longerString = longest (“ alice”，“ bob”) ;/Error！数字没有长度属性 notOK = longest (10,100) ; 类型‘ number’的参数不能分配给类型‘{ length: number; }’。类型‘ number’的 2345 个参数不能分配给类型‘{ length: number; }’的参数。试试


```

There are few interesting things to note in this example. We allowed TypeScript to _infer_ the return type of `longest`. Return type inference also works on generic functions.

在这个例子中几乎没有什么有趣的东西值得注意。我们允许打字稿推断出最长的返回类型。返回类型推断也适用于泛型函数。

Because we constrained `Type` to `{ length: number }`, we were allowed to access the `.length` property of the `a` and `b` parameters. Without the type constraint, we wouldn’t be able to access those properties because the values might have been some other type without a length property.

因为我们将 Type 限制为 {length: number} ，所以允许访问。A 和 b 参数的长度特性。如果没有类型约束，我们将无法访问这些属性，因为这些值可能是没有长度属性的其他类型。

The types of `longerArray` and `longerString` were inferred based on the arguments. Remember, generics are all about relating two or more values with the same type!

根据参数推断出 longerArray 和 longerString 的类型。记住，泛型都是关于用同一类型关联两个或多个值的！

Finally, just as we’d like, the call to `longest(10, 100)` is rejected because the `number` type doesn’t have a `.length` property.

最后，正如我们所希望的，对 longest (10,100) 的调用被拒绝，因为号码类型没有。长度特性。

### [](#working-with-constrained-values)Working with Constrained Values

使用约束值

Here’s a common error when working with generic constraints:

下面是处理一般约束时的一个常见错误:

``` ts

function minimumLength<Type extends { length: number }>(

 obj: Type,

 minimum: number

): Type {

 if (obj.length >= minimum) {

 return obj;

 } else {

 return { length: minimum };

Type '{ length: number; }' is not assignable to type 'Type'.
  '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.2322Type '{ length: number; }' is not assignable to type 'Type'.
  '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.

  }

}

[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgAzAVwDsBjAFwEs4TQBbKkq+o+gGUhIHMKALADwAVAJ4AHSKEgAPClwAmiUAG9QAGy68+qEmwBGMUAF8AfAAp8oUHD0ArVKIkAaSwyYs2O-THwBKB+KSyq5UBKBmNrYAdBo8-KAmALxuzKz0viquVtCQFETQdJEA3K5GUmqIQVmgOXkFKuqa-KiMqWzGJXhWRvhGQA)

函数 miniumlength  (obj: Type，minimum: number) : Type { if (obj.length > = minimum){ return obj; } else { return { length: minimum } ; Type’{ length: number; }’不能分配给 Type’Type’{ length: number; }’可以分配给类型‘ Type’的约束，但是‘ Type’可以用不同的约束子类型‘{ length: number; }’. 2322 Type’{ length: number; }’不能分配给类型‘ Type’。’{ length: number; }’可以分配给类型‘ Type’的约束，但是‘ Type’可以使用不同的约束子类型‘{ length: number; }’} 实例化试试


```

It might look like this function is OK - `Type` is constrained to `{ length: number }`, and the function either returns `Type` or a value matching that constraint. The problem is that the function promises to return the _same_ kind of object as was passed in, not just _some_ object matching the constraint. If this code were legal, you could write code that definitely wouldn’t work:

这个函数可能看起来像是 OK-Type 被限制为 {length: number} ，并且函数返回 Type 或匹配该限制的值。问题在于，该函数承诺返回与传入的对象类型相同的对象，而不仅仅是匹配约束的对象。如果这些代码是合法的，你可以编写一些肯定不能工作的代码:

``` ts

// 'arr' gets value { length: 6 }

const arr = minimumLength([1, 2, 3], 6);

// and crashes here because arrays have

// a 'slice' method, but not the returned object!

console.log(arr.slice(0));

[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFstUsDkCAZEVAcwwAsAeAFQE8AHBEADw2uADO8AN7wI1OvQBc8VOQBGIGPAC+APgAUAWABQ8eDnkArGW04AaXfqIkyBGXIKKYugJSmOIANy6A9L-gAWmCwZAxgwL8AgHJYGGj4GhAMIQA3KAhkBFFxWgYZADZVXTA8AQx4OPgAXkJiUnIqPPoNAG0ARnN4ACYugGYAXS6C1x8df0rUYHgwGCgBehAhRbh4RTAoZAEEOKhWZahUkCjK+GiBCCwwEASCZPocYC75MNkcCoYEOAxkGFQQaaGIzgDAAQhKZRw4gAdBAcDQNHFoRcriANAAGVyjIA)

Ts//‘ arr’获取值 {length: 6} const arr = minimumLength ([1,2,3] ，6) ;// 在这里崩溃，因为数组有 //a‘ slice’方法，但没有返回对象！console.log (arr.slice (0)) ; Try


```

### [](#specifying-type-arguments)Specifying Type Arguments

指定类型参数

TypeScript can usually infer the intended type arguments in a generic call, but not always. For example, let’s say you wrote a function to combine two arrays:

通常可以在泛型调用中推断预期的类型参数，但并不总是如此。例如，假设你写了一个函数来组合两个数组:

``` ts

function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {

 return arr1.concat(arr2);

}

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBOBbARjMBTAPAFQE8AHbAPgAoBDAJxoEYAuRI0gbQF0AaRWmgJmatsnAJRCSIjogDeAWABQiRDWxQQNJH3oA6FJCpRqdfqIDcigL5A)

Tsfunction combine < Type > (arr1: Type [] ，arr2: Type []) : Type []{ return arr1.concat (arr2) ; } Try


```

Normally it would be an error to call this function with mismatched arrays:

通常用不匹配的数组调用这个函数是错误的:

``` ts

const arr = combine([1, 2, 3], ["hello"]);

Type 'string' is not assignable to type 'number'.2322Type 'string' is not assignable to type 'number'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oLACgATSAYwBsBDaSUAMwFcA7YgFwEs4HRi4BbAI1YNIAHgAqATwAOkAHwAKStACMqCdIDaAXQA0oRWlVTIWgJSGNmgNz4QoALQPidZg7v5uDRMz2xQAXi5eASE5dSVdNF0MHVB1ACIAC0hSUjg4zRNLIA)

Tssconst arr = combled ([1,2,3] ，[“ hello”]) ; 类型‘ string’不能分配给类型‘ number’。试试


```

If you intended to do this, however, you could manually specify `Type`:

但是，如果你打算这么做，你可以手动指定 Type:

``` ts

const arr = combine<string | number>([1, 2, 3], ["hello"]);

[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXzBwFsAjLVEAHgBUBPABxAD4AKWGARgC547GBtALoAaeOwBMPPiCEBKKQxmCA3AFgAUAHpN8ALT6wyDPt0bCqAM4YxMGPAC8BYmQqUrMcgHN4AH3ipkUhAYVn4OUXFRAGYReH4AIgALEAgIHHjBWWUgA)

结合  ([1,2,3] ，[“ hello”]) ; 尝试


```

### [](#guidelines-for-writing-good-generic-functions)Guidelines for Writing Good Generic Functions

编写良好通用函数的指南

Writing generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they aren’t needed can make inference less successful, frustrating callers of your function.

编写泛型函数很有趣，而且很容易被类型参数冲昏头脑。拥有太多的类型参数，或者在不需要它们的地方使用约束，可能会导致推理不太成功，使函数调用者感到沮丧。

#### [](#push-type-parameters-down)Push Type Parameters Down

下推类型参数

Here are two ways of writing a function that appear similar:

这里有两种编写类似函数的方法:

```ts

function firstElement1<Type>(arr: Type[]) {

 return arr[0];

}

function firstElement2<Type extends any[]>(arr: Type) {

 return arr[0];

}

// a: number (good)

const a = firstElement1([1, 2, 3]);

// b: any (bad)

const b = firstElement2([1, 2, 3]);

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAjADwAqAngA54B8AFAIaqoBciN9A2gLoBKRAG8AsAChEiVHighUSNql4AGfgG5JAX0mTQkWAmRpMuQsSgAmKnTyI8ADyjEAJukQsw1Ac2VcePGFxKRk5BSV2NU0dPQkAenjPLjAQAgAjPFREJgBzODhXQUkIBExPRABeEwxsfCISUiZeUgAaRCt2gGYhLQSk9K4vahz0liKSsqhEdKqas3rLK2a2ju7eoA)

1 < Type > (arr: Type []){ return arr [0] ; } function firstElement2 < Type extends any [] > (arr: Type){ return arr [0] ; }/a: number (good) const a = firstElement1([1,2,3]) ;//b: any (bad) const b = firstElement2([1,2,3]) ; Try


```

These might seem identical at first glance, but `firstElement1` is a much better way to write this function. Its inferred return type is `Type`, but `firstElement2`’s inferred return type is `any` because TypeScript has to resolve the `arr[0]` expression using the constraint type, rather than “waiting” to resolve the element during a call.

乍一看，这些函数似乎是相同的，但 firstelement1 是编写这个函数的更好方法。它的推断返回类型是 Type，但 firstelement2 的推断返回类型是 any，因为 TypeScript 必须使用约束类型解析 arr [0] 表达式，而不是在调用期间 “等待” 解析元素。

> **Rule**: When possible, use the type parameter itself rather than constraining it
> 
> 规则：如果可能的话，使用类型参数本身而不是约束它

#### [](#use-fewer-type-parameters)Use Fewer Type Parameters

使用更少的类型参数

Here’s another pair of similar functions:

下面是另外一对类似的函数:

``` ts

function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {

 return arr.filter(func);

}

function filter2<Type, Func extends (arg: Type) => boolean>(

 arr: Type[],

 func: Func

): Type[] {

 return arr.filter(func);

}

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAbKBTATgRgDwAqAngA4YB8AFAIZZYBcixZA2gLoA0y4EjNWAc0bMMASkQBecogBGcOKgzUwo4aQztEAbwCwAKESIsGKCCxJaWAHQp02SqEiiA3PoC++-Y+jwktzFgATITqXABiPIgYAB6YYAAmAM6I-EJM6uJSsvKKylT6hpZqrJwF3JCMEZD6qukl2mXGpuaIljZoAQ48Lu5AA)

Tsfunction filter1 < Type > (arr: Type [] ，Func: (arg: Type) = > boolean) : Type []{ return arr.filter (Func) ; } function filter2 < Type，Func extends (arg: Type) = > boolean > (arr: Type [] ，Func: Func) : Type []{ return arr.filter (Func) ; } Try


```

We’ve created a type parameter `Func` that _doesn’t relate two values_. That’s always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason. `Func` doesn’t do anything but make the function harder to read and reason about!

我们创建了一个类型参数 Func，它不关联两个值。这总是一个危险信号，因为这意味着调用者想要指定类型参数，就必须无缘无故地手动指定一个额外的类型参数。Func 什么都不做，只是让函数更难阅读和推理！

> **Rule**: Always use as few type parameters as possible
> 
> 规则：总是使用尽可能少的类型参数

#### [](#type-parameters-should-appear-twice)Type Parameters Should Appear Twice

类型参数应该出现两次

Sometimes we forget that a function might not need to be generic:

有时候我们忘记了一个函数可能不需要是通用的:

``` ts

function greet<Str extends string>(s: Str) {

 console.log("Hello, " + s);

}

greet("world");

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QDwGUqqLoAeU6YAJgM6JUExjIB8AFFQFyL6oCUiA3gFgAUIkQQEVOABt0AOmlxkLAEQAJdNMUAaRCsQBqWjwDcIgL4iRaTFFUB3OKmkUVpoA)

(s: Str){ console.log (“ Hello,”+ s) ; } greet (“ world”) ; Try


```

We could just as easily have written a simpler version:

我们也可以很容易地写出一个更简单的版本:

``` ts

function greet(s: string) {

 console.log("Hello, " + s);

}

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQGcBciuUqMYyAlIgN4CwAUIohArnADboB07cy2AIgAS6drwA0iAYgDURCgG4GAXyA)

(s: string){ console.log (“ Hello,”+ s) ; } Try


```

Remember, type parameters are for _relating the types of multiple values_. If a type parameter is only used once in the function signature, it’s not relating anything.

请记住，类型参数用于关联多个值的类型。如果类型参数在函数签名中只使用一次，那么它不关联任何东西。

> **Rule**: If a type parameter only appears in one location, strongly reconsider if you actually need it
> 
> 规则：如果一个类型参数只出现在一个位置，请强烈重新考虑是否实际需要它

[](#optional-parameters)Optional Parameters

可选参数


---------------------------------------------------

Functions in JavaScript often take a variable number of arguments. For example, the `toFixed` method of `number` takes an optional digit count:

函数通常带有可变数量的参数。例如，toFixed 的数字方法有一个可选的数字计数:

``` ts

function f(n: number) {

 console.log(n.toFixed()); // 0 arguments

 console.log(n.toFixed(3)); // 1 argument

}

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFGAXIsIC2AjAUwCcBKRAbwFgAoRRCBAZzgBsCA6FuAczXajgAxGAA8CAExQkSAbkQB6eYgAMiAIZFuuAmCiMadBmGZtOPPgOFjJAZmlzFiAIzrN23TQC+QA)

Tsfunction f (n: number){ console.log (ntofixed ()) ;//0 arguments console.log (ntofixed (3) ;//1 argument } Try


```

We can model this in TypeScript by marking the parameter as _optional_ with `?`:

我们可以在打字稿中通过将参数标记为可选的？:

``` ts

function f(x?: number) {

 // ...

}

f(); // OK

f(10); // OK

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFADwPwC5FhAWwCMBTAJwEpEBvAWAChFEB6JxAOg-oF97VyBuZqwDyAaV4oAjAAYBQxGKA)

Tsfunction f (x? : number){//... } f () ;//OKf (10) ;//OKTry


```

Although the parameter is specified as type `number`, the `x` parameter will actually have the type `number | undefined` because unspecified parameters in JavaScript get the value `undefined`.

尽管该参数被指定为 type number，但是 x 参数实际上具有类型 number | undefined，因为 JavaScript 中未指定的参数获得了未定义的值。

You can also provide a parameter _default_:

你也可以提供一个参数默认值:

``` ts

function f(x = 10) {

 // ...

}

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFAD0QXkQRgAwCUiA3gLABQiiA9NYgHSMUC+QA)

Tsfunction f (x = 10){//... } Try


```

Now in the body of `f`, `x` will have type `number` because any `undefined` argument will be replaced with `10`. Note that when a parameter is optional, callers can always pass `undefined`, as this simply simulates a “missing” argument:

现在在 f 的主体中，x 的类型为 number，因为任何未定义的参数都将被替换为 10。请注意，当一个参数是可选的时候，调用方总是可以传递未定义的参数，因为这只是模拟了一个 “缺少的” 参数:

``` ts

declare function f(x?: number): void;

// cut

// All OK

f();

f(10);

f(undefined);

[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVIAoAPAfgC55VkBbAIxBgEoKA3HLYAbgFgAoAen7wwyDH0HwAghAjwA8gGk+iAox68VARgAMa5QTShEWVCGBqgA)

Tsdeclare 函数 f (x? : number) : void;//cut/All OKf () ; f (10) ; f (undefined) ; Try


```

### [](#optional-parameters-in-callbacks)Optional Parameters in Callbacks

回调函数中的可选参数

Once you’ve learned about optional parameters and function type expressions, it’s very easy to make the following mistakes when writing functions that invoke callbacks:

一旦你了解了可选参数和函数类型表达式，在编写调用回调函数时很容易出现以下错误:

``` ts

function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {

 for (let i = 0; i < arr.length; i++) {

 callback(arr[i], i);

 }

}

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWwJ4DE4CcCiBDCACwAo8ssAuRPMVAbQF0AaRCPAG3YCMCBrK0lgDmVGqhYwwAEwCmADwD8VMCGRcZWAJSIAvAD5EANzgwp2gN4BYAFCJEwbImLsZURDF2IADAG53iAB5qcgA6FzAhKEI-GABqWIsbOzs2Th4IXkEsOhhmd00fJMQAXxtioA)

函数 myForEach (arr: any [] ，callback: (arg: any，index？: number) = > void){ for (let i = 0; i < arr.length; i + +){ callback (arr [ i ] ，i) ; }


```

What people usually intend when writing `index?` as an optional parameter is that they want both of these calls to be legal:

人们在编制索引时通常打算做什么？作为一个可选参数是，他们希望这两个调用都是合法的:

``` ts

myForEach([1, 2, 3], (a) => console.log(a));

myForEach([1, 2, 3], (a, i) => console.log(a, i));

[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMaCwAoAE0gGMAbAQ2klADMBXAOxIBcBLOR0AWwE8AxBAFEKJABYAKAqFBVoqCo14BtALoAaaaBIUyZAEaiA1qglUA5gqXrQbRsQAeAflSN63fTACUoALwA+UAA3ODZCAi9UELCAbgIQUABaZJJ6FmTEgj5BaBFxCWUARhs0GywNUDMfAO1ORDgySAA6MjhzKq84-GzhUUkikrKKsxs2asCSOobm1vaKUa9OoA)

Tmyforeach ([1,2,3] ，(a) = > console.log (a) ; myForEach ([1,2,3] ，(a，i) = > console.log (a，i) ; Try


```

What this _actually_ means is that _`callback` might get invoked with one argument_. In other words, the function definition says that the implementation might look like this:

这实际上意味着回调可以用一个参数调用。换句话说，函数定义表明实现可能是这样的:

``` ts

function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {

 for (let i = 0; i < arr.length; i++) {

 // I don't feel like providing the index today

 callback(arr[i]);

 }

}

[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMaCwAoAMwFcA7AYwBcBLOU0AWwE8AxBAUQENyALACk6xUnUkwDaAXQA0ocpwA28gEbcA1qgHQA5sNEzqpACaQAHgH5UpYgyUwAlKAC8APlAA3ONUMOA3gVCghAigfPKQlKDUTqAADADckaAAPKCC0AB0YaRalDwJ1ADUBb7+AaAgoACSoIZ0AOQRhJCQ8qDy1KqQoAAO8G5eBlqguV0GxibDcIacTKUBcooq5Kqa0GLUEnZxpQC+BDtAA)

函数 myForEach (arr: any [] ，callback: (arg: any，index？: number) = > void){ for (let i = 0; i < arr.length; i + +){///i don’t feel like providing the index today callback (arr [ i ] ; }


```

In turn, TypeScript will enforce this meaning and issue errors that aren’t really possible:

反过来，打字稿会强化这种意义，并发出不太可能出现的错误:

``` ts

myForEach([1, 2, 3], (a, i) => {

 console.log(i.toFixed());

Object is possibly 'undefined'.2532Object is possibly 'undefined'.

});

[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMaCwAoAE0gGMAbAQ2klADMBXAOxIBcBLOR0AWwE8AxBAFEKJABYAKAqFBVoqCo14BtALoAaaaBIUyZAEaiA1qglUA5gqXrQbRsQAeAflSN63fTACUoALwA+UAA3ODZCAi9UELCAbgIQUABaZJJ6FmTEgj5BaBFxCWUARhs0GywNUDMbNh8A0ABvLRJORDgySAA6MjhzCTYOljh+NgdIQgkvLzj8AF8poA)

Tmyforeach ([1,2,3] ，(a，i) = > { console.log (i.toFixed ()) ; Object 可能是‘ undefined’. 2532 Object 可能是‘ undefined’. }) ;


```

In JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored. TypeScript behaves the same way. Functions with fewer parameters (of the same types) can always take the place of functions with more parameters.

在 JavaScript 中，如果调用一个参数比参数多的函数，额外的参数就会被忽略。的行为也是这样的。具有较少参数的函数 (具有相同的类型) 总是可以取代具有较多参数的函数。

> When writing a function type for a callback, _never_ write an optional parameter unless you intend to _call_ the function without passing that argument
> 
> 在为回调编写函数类型时，永远不要编写可选参数，除非您打算在不传递该参数的情况下调用该函数

[](#function-overloads)Function Overloads

函数过载


-------------------------------------------------

Some JavaScript functions can be called in a variety of argument counts and types. For example, you might write a function to produce a `Date` that takes either a timestamp (one argument) or a month/day/year specification (three arguments).

一些 JavaScript 函数可以通过各种参数计数和类型来调用。例如，您可以编写一个函数来生成一个接受时间戳 (一个参数) 或月 / 日 / 年规范 (三个参数) 的 Date。

In TypeScript, we can specify a function that can be called in different ways by writing _overload signatures_. To do this, write some number of function signatures (usually two or more), followed by the body of the function:

在打字稿中，我们可以通过写重载签名来指定一个可以以不同方式调用的函数。要做到这一点，写一些函数签名 (通常是两个或更多) ，后面跟着函数体:

``` ts

function makeDate(timestamp: number): Date;

function makeDate(m: number, d: number, y: number): Date;

function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {

 if (d !== undefined && y !== undefined) {

 return new Date(y, mOrTimestamp, d);

 } else {

 return new Date(mOrTimestamp);

 }

}

const d1 = makeDate(12345678);

const d2 = makeDate(5, 5, 5);

const d3 = makeDate(1, 3);

No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.2575No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsGCwAoAMwFcA7AYwBcBLOU0AWwEMBrSAEScsgAoaHIiSkwYAHVKWIMARjACUqTtwDcBEhRp1GrDl14MJU2dAA0oACaGZMMwE8rxhaCWRVRMlVr1mbFzwYA8tAAKtQCQiLioJLWphYA-A42oLaJ0UbyinqgAN4EoKDUhKA85qAAhAC8laBk5pCE1KSQZQBkrSkV1bWk9Y3N5nK5+QWg0JCUxND0zQDuzno8tmaBIWGCwmJmg24FAL6gkAA2iJDD+KNjE1MzkPN+q6Hhm6Jyu6B7BJ-45HRCFgBGUA1Hy6bg8AFoADMABYMAA2LAADjeBF+pH+5jQwO0vkWGDMBNAGFRPz+lAsUJxoL8ALMULeQA)

函数 makeDate (timestamp: number) : Date; 函数 makeDate (m: number，d: number，y: number) : Date; 函数 makeDate (mOrTimestamp: number，d？号码 y？: number) : Date { if (d！= undefined & y！= = undefined){ return new Date (y，mOrTimestamp，d) ; } else { return new Date (mOrTimestamp) ; } const d1 = makeDate (12345678) ; const d2 = makeDate (5,5,5) ; const d3 = makeDate (1,3) ; 没有重载期望有 2 个参数，但是确实存在预期有 1 或 3 个参数的重载。2575 No overload 期望有 2 个参数，但是确实存在预期有 1 或 3 个参数的重载。试试


```

In this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the _overload signatures_.

在这个例子中，我们写了两个重载：一个接受一个参数，另一个接受三个参数。前两个签名称为重载签名。

Then, we wrote a function implementation with a compatible signature. Functions have an _implementation_ signature, but this signature can’t be called directly. Even though we wrote a function with two optional parameters after the required one, it can’t be called with two parameters!

然后，我们编写了一个具有兼容签名的函数实现。函数有一个实现签名，但是这个签名不能直接调用。即使我们在必需的参数之后写了一个带有两个可选参数的函数，它也不能用两个参数来调用！

### [](#overload-signatures-and-the-implementation-signature)Overload Signatures and the Implementation Signature

重载签名和实现签名

This is a common source of confusion. Often people will write code like this and not understand why there is an error:

这是一个常见的困惑来源。通常人们写这样的代码并不理解为什么会有错误:

``` ts

function fn(x: string): void;

function fn() {

 // ...

}

// Expected to be able to call with zero arguments

fn();

Expected 1 arguments, but got 0.2554Expected 1 arguments, but got 0.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYCwAoAMwFcA7AYwBcBLOU0Q0gCgA9VFLprSBzASlQA3ONQAmAbgIkKNOg2Z9QAbwKhQIUADptBAL4ENAURYAHSFUijQlOKABGkUAEM7AG0c3Q5J69egA7tSUABagAF4wtk7QPMQAtpCklIhSCuJAA)

Tsfunction fn (x: string) : void; function fn (){///... }/ 期望能够调用 0 个参数；期望有 1 个参数，但是得到 0.2554 个参数，但是得到 0。试试


```

Again, the signature used to write the function body can’t be “seen” from the outside.

同样，用于写函数体的签名不能从外部 “看到”。

> The signature of the _implementation_ is not visible from the outside. When writing an overloaded function, you should always have _two_ or more signatures above the implementation of the function.
> 
> 从外部看不到实现的签名。在编写重载函数时，应该始终在函数实现之上有两个或多个签名。

The implementation signature must also be _compatible_ with the overload signatures. For example, these functions have errors because the implementation signature doesn’t match the overloads in a correct way:

实现签名还必须与重载签名兼容。例如，这些函数有错误，因为实现签名与重载不匹配:

``` ts

function fn(x: boolean): void;

// Argument type isn't right

function fn(x: string): void;

This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.

function fn(x: boolean) {}

[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAsAFABmArgHYDGALgJZxmhFkAUAHqgEZxwA2kAhmQCUqAG5waAEwDchEKACC0AOYkAtpDJVQVAJ4AHSKBqIyAcm3QaygBZVCpSrXqMW7UIipWyykaHFSssTk1HQMTGyc3HyCQqAA3gC+QA)

Tsfunction fn (x: boolean) : void;//Argument type isn’t rightfunction fn (x: string) : void; 此重载签名与其实现签名不兼容


```

``` ts

function fn(x: string): string;

// Return type isn't right

function fn(x: number): boolean;

This overload signature is not compatible with its implementation signature.2394This overload signature is not compatible with its implementation signature.

function fn(x: string | number) {

  return "oops";

}

[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAsAFABmArgHYDGALgJZxmhFkAUAHqoldDWQOYCUHLj14BuQiFAAlSFRLQGVAJ4AHSKBqIyAciqhuvABZVCpSrXqMW7UGRIBbAEYxBoR3DgAbSAEMy44nJqOgYmNiFuPlAAH1sHZ2h+UABvQlB9WXkGACIPFURsgIBfIA)

Tsfunction fn (x: string) : string;//Return type isn’t rightfunction fn (x: number) : boolean; 此重载签名与其实现签名不兼容。2394 此重载签名与其实现签名 signature.function fn (x: string | number){ Return “ oops”; } Try


```

### [](#writing-good-overloads)Writing Good Overloads

写好的超负荷

Like generics, there are a few guidelines you should follow when using function overloads. Following these principles will make your function easier to call, easier to understand, and easier to implement.

与泛型一样，在使用函数重载时也应该遵循一些准则。遵循这些原则将使您的函数更容易调用、更容易理解和更容易实现。

Let’s consider a function that returns the length of a string or an array:

让我们考虑一个返回字符串或数组长度的函数:

``` ts

function len(s: string): number;

function len(arr: any[]): number;

function len(x: any) {

 return x.length;

}

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQGcBcitQBOMYA5gJR5ggC2ARqoQNwCwAUKJLAiuhgIaFCefmACeAbQC6lRNXqNWHcNHhI0mAB4jx5RAG92iRIVRQQhJJoB0G0lAAWSgL5A)

Tsfunction len (s: string) : number; function len (arr: any []) : number; function len (x: any){ return x.length; } Try


```

This function is fine; we can invoke it with strings or arrays. However, we can’t invoke it with a value that might be a string _or_ an array, because TypeScript can only resolve a function call to a single overload:

这个函数很好；我们可以用字符串或数组调用它。但是，我们不能用一个字符串或数组的值来调用它，因为 TypeScript 只能将一个函数调用解析为一个重载:

``` ts

len(""); // OK

len([0]); // OK

len(Math.random() > 0.5 ? "hello" : [0]);

No overload matches this call.
  Overload 1 of 2, '(s: string): number', gave the following error.
    Argument of type 'number[] | "hello"' is not assignable to parameter of type 'string'.
      Type 'number[]' is not assignable to type 'string'.
  Overload 2 of 2, '(arr: any[]): number', gave the following error.
    Argument of type 'number[] | "hello"' is not assignable to parameter of type 'any[]'.
      Type 'string' is not assignable to type 'any[]'.2769No overload matches this call.
  Overload 1 of 2, '(s: string): number', gave the following error.
    Argument of type 'number[] | "hello"' is not assignable to parameter of type 'string'.
      Type 'number[]' is not assignable to type 'string'.
  Overload 2 of 2, '(arr: any[]): number', gave the following error.
    Argument of type 'number[] | "hello"' is not assignable to parameter of type 'any[]'.
      Type 'string' is not assignable to type 'any[]'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYBsBOAsAFAAmkAxgDYCG0koAZgK4B2pALgJZxOjmRMAUKUIlbR2TAOYBKVEwYBbAEYwA3IRIVqtRiw5cefftWipKTAJ4BtALozQcpasIhQAWnekGrd68K8BAEQBUiqgLgDyANJ+hpYADLahEdEE-vwAspSsABYAdNBmRHDy-FKgAHygcbkArKAA-KAB2ZDk5HABoKjxiUA)

Tslen (”) ;//OKlen ([0]) ;//OKlen (Math.random () > 0.5？“ hello”: [0]) ; 没有与此呼叫匹配的超载。重载 2 中的 1,’(s: string) : number’，导致以下错误。类型 “ number [] | “ hello” 的参数不能分配给类型 “ string” 的参数。键入‘ number []’不能分配给键入‘ string’。重载 2 中的 2,’(arr: any []) : number’，给出以下错误。类型‘ number [] | “ hello”’的参数不能分配给类型‘ any []’的参数。类型 “ string” 不能分配给类型 “ any []”。2769 没有重载匹配此调用。重载 2 中的 1,’(s: string) : number’，导致以下错误。类型 “ number [] | “ hello” 的参数不能分配给类型 “ string” 的参数。键入‘ number []’不能分配给键入‘ string’。重载 2 中的 2,’(arr: any []) : number’，给出了以下错误。类型‘ number [] | “ hello”’的参数不能分配给类型‘ any []’的参数。类型 “ string” 不能分配给类型 “ any []”。试试


```

Because both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:

因为两个重载有相同的参数计数和相同的返回类型，我们可以改写一个非重载版本的函数:

``` ts

function len(x: any[] | string) {

 return x.length;

}

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQA8BciCGYAngNoC6iAPogM5QBOMYA5gJSIDeAsAFCKL1UUEPSRYAdGhZQAFgG5eAXyA)

Tsfunction len (x: any [] | string){ return x.length; } Try


```

This is much better! Callers can invoke this with either sort of value, and as an added bonus, we don’t have to figure out a correct implementation signature.

这样好多了！调用方可以使用任意一种值来调用这个函数，作为额外的好处，我们不需要找出正确的实现签名。

> Always prefer parameters with union types instead of overloads when possible
> 
> 如果可能的话，总是倾向于使用联合类型的参数，而不是重载

### [](#declaring-this-in-a-function)Declaring `this` in a Function

在函数中声明它

TypeScript will infer what the `this` should be in a function via code flow analysis, for example in the following:

将通过代码流分析推断函数中的这个值应该是什么，例如:

``` ts

const user = {

 id: 123,

 admin: false,

 becomeAdmin: function () {

 this.admin = true;

 },

};

[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBArhApgJxgXhgbwLACgYwCWAJgFwwCMATAMwA0eeBAhsQLaFjkBmzANkgb4YAI0Sg2iAILtOPOGGBRC4GAAoAlFiYEYUABaEIAOlYcw6PcjiIA3DoC+Qh7aA)

123，admin: false，be/admin: function (){ this.admin = true; } ，} ; Try


```

TypeScript understands that the function `user.becomeAdmin` has a corresponding `this` which is the outer object `user`. `this`, _heh_, can be enough for a lot of cases, but there are a lot of cases where you need more control over what object `this` represents. The JavaScript specification states that you cannot have a parameter called `this`, and so TypeScript uses that syntax space to let you declare the type for `this` in the function body.

打印脚本明白函数 user.be/admin 有一个对应的这个外部对象用户。对于很多情况来说，这已经足够了，但是在很多情况下，你需要更多地控制它代表的物体。JavaScript 规范规定不能有一个名为 this 的参数，因此 TypeScript 使用这个语法空间来让您在函数体中声明这个参数的类型。

``` ts

interface DB {

 filterUsers(filter: (this: User) => boolean): User[];

}

const db = getDB();

const admins = db.filterUsers(function (this: User) {

 return this.admin;

});

[Try](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgKoGdrIN4FgBQyywAJgFzIgCuAtgEbQDcBRcJNoFdA9twDYQ4IZvgC+BEhAR84UFAm4h0YZAHMIYACIAhCgAoAlMgC8APmQ6RAeivIAtA4RUwDuwVCRYiFDpwtkMMB8nhjQ6HqBwdD6YAAWwOgUoVBGZsg8-IIgBkmYUADaALoi4vgECkoqJHQmaho6hiIVyshsHEq11QB0kSF54TBUIAhgwIrIenEJudBGeITIcmBUUCDIU+hdbaAlBoxAA)

Tsinterface DB { filterUsers (filter: (this: User) = > boolean) : User [] ; } const DB = getDB () ; const admins = DB.filterUsers (function (this: User){ return this.admin; }) ; Try


```

This pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to use `function` and not arrow functions to get this behavior:

这种模式在回调样式的 api 中很常见，其中另一个对象通常控制调用函数的时间。注意，你需要使用函数而不是箭头函数来获得这个行为:

``` ts

interface DB {

 filterUsers(filter: (this: User) => boolean): User[];

}

const db = getDB();

const admins = db.filterUsers(() => this.admin);

The containing arrow function captures the global value of 'this'.  
Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.7041  
7017The containing arrow function captures the global value of 'this'.  
Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygOwAYAsBGdGc0BYAKAEsA7AFxgDMBDAY0lAFVEZQBvU0UMgCaoKAVwC2AIxgBuXv0QBBAWMqoJcOABtI9CrJIBfUgMiNN9aC0ZwKiKqADmkKgBEAQqgAUASlABeAD5Qd30QUABaSMYRKkjw0koaaAZmYLduOVoyTST2GERPLJyYLyoACzIUNg5oX0DQdS0dCm9UPOgAbQBdfSMSUmtbewEJf0dndx99QbtQemVKRDGRgDoi3JqCn38g8sqV+ZUW6SA)

Tsinterface DB {filterUsers (filter: (this: User) = > boolean) : User [] ; } const DB = getDB () ; const admins = DB.filterUsers (() = > this.admin) ; 包含箭头的函数捕获‘ this’的全局值。元素隐式具有 “ any” 类型，因为类型 “ typeof globalThis” 没有索引签名。元素隐式具有 “ any” 类型，因为类型 “ typeofglobalthis” 没有索引签名。试试


```

[](#other-types-to-know-about)Other Types to Know About

其他需要了解的类型


--------------------------------------------------------------------

There are some additional types you’ll want to recognize that appear often when working with function types. Like all types, you can use them everywhere, but these are especially relevant in the context of functions.

在使用函数类型时，还有一些其他类型需要识别，这些类型经常出现。像所有类型一样，您可以在任何地方使用它们，但是这些类型在函数的上下文中特别相关。

### [](#void)`void

空洞

void` represents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any `return` statements, or doesn’t return any explicit value from those return statements:

Void 表示不返回值的函数的返回值。当函数没有返回语句，或者返回语句没有返回任何明确的值时，它就是推断类型:

``` ts

// The inferred return type is void

function noop() {

 return;

}

[Try](https://www.typescriptlang.org/play/#code/PTAEBUAsFNQSwHYDNoCdXQCagwFwK6oKi4CeADrHAM6gBuA9nJgLABQS+CAxrnA8QQMG5ABQBKUAG92oHNAJEA3OwC+QA)

Ts// 推断出的返回类型是 voidfunction noop (){ return;} Try


```

In JavaScript, a function that doesn’t return any value will implicitly return the value `undefined`. However, `void` and `undefined` are not the same thing in TypeScript. There are further details at the end of this chapter.

在 JavaScript 中，不返回任何值的函数将隐式返回未定义的值。然而，void 和 undefined 在打字稿中并不是一回事。本章最后还有更多的细节。

> `void` is not the same as `undefined`.
> 
> 空洞不等于未定义。

### [](#object)`object

对象

The special type `object` refers to any value that isn’t a primitive (`string`, `number`, `bigint`, `boolean`, `symbol`, `null`, or `undefined`). This is different from the _empty object type_ `{ }`, and also different from the global type `Object`. It’s very likely you will never use `Object`.

特殊类型对象引用任何不是基元的值 (string、 number、 bigint、 boolean、 symbol、 null 或 undefined)。这不同于空对象类型 {} ，也不同于全局类型 Object。很有可能你永远不会使用 Object。

> `object` is not `Object`. **Always** use `object`!
> 
> 对象不是对象。始终使用对象！

Note that in JavaScript, function values are objects: They have properties, have `Object.prototype` in their prototype chain, are `instanceof Object`, you can call `Object.keys` on them, and so on. For this reason, function types are considered to be `object`s in TypeScript.

注意，在 JavaScript 中，函数值是对象：它们具有属性，在原型链中具有 Object.prototype，是 instanceof Object，可以在它们上面调用 Object.keys，等等。由于这个原因，函数类型在打字稿中被认为是对象。

### [](#unknown)`unknown

未知的

The `unknown` type represents _any_ value. This is similar to the `any` type, but is safer because it’s not legal to do anything with an `unknown` value:

未知类型表示任何值。这类似于任何类型，但是更安全，因为任何未知值都是不合法的:

``` ts

function f1(a: any) {

 a.b(); // OK

}

function f2(a: unknown) {

 a.b();

Object is of type 'unknown'.2571Object is of type 'unknown'.

}

[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGAsAFABmArgHYDGALgJZxmhE4AUAhqq2QJ4CUoA3oVChWAOgBGzHgG5QIUAHkA0oQC+hUpVr1GaNqnIBrMnADuZPoILCxkmWqA)

Tsfunction f1 (a: any){ a.b () ;//OK } function f2 (a: unknown){ a.b () ; Object is type‘ unknown’. 2571 Object is type‘ unknown’. } 试试


```

This is useful when describing function types because you can describe functions that accept any value without having `any` values in your function body.

这在描述函数类型时非常有用，因为您可以描述接受任何值的函数，而函数体中没有任何值。

Conversely, you can describe a function that returns a value of unknown type:

相反，你可以描述一个返回未知类型值的函数:

``` ts

function safeParse(s: string): unknown {

 return JSON.parse(s);

}

// Need to be careful with 'obj'!

const obj = safeParse(someRandomString);

[Try](https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3mpBbEASlCsHgMoYwCWKA5gFzaU20DcAsAFAD038AtILABXDIP5cAZsJRgMVVNiiSQABVhoQACjSNM1OgEpGMgNYokAdxTwA3l3jw4GYTBsApMgHkAcgDoABw1tNEMOTgBfLi5eeB8QEGB4DCR4ACMEMFgQaQh4SyoMAAt4AHIkNIArUoBCLmR0LArK+ABeJRV1GE0dPEJiUlwKA1owoA)

Tsfunction safeParse (s: string) : unknown { return JSON.parse (s) ; }// 需要小心使用‘ obj’! const obj = safeParse (someRandomString) ; 尝试


```

### [](#never)`never

从来没有

Some functions _never_ return a value:

有些函数从不返回值:

``` ts

function fail(msg: string): never {

 throw new Error(msg);

}

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAhjANgCgLYGcDmAXIrlAE4xj4CUxYApgG71mIDeAsAFCKJQAWZOAHdEDUQFEyQsjgLUA3NwC+QA)

Tsfunction fail (msg: string) : never { throw new Error (msg) ; } Try


```

The `never` type represents values which are _never_ observed. In a return type, this means that the function throws an exception or terminates execution of the program.

Never 类型表示从未观察到的值。在返回类型中，这意味着函数抛出异常或终止程序的执行。

never` also appears when TypeScript determines there’s nothing left in a union.

当打字稿确定工会中没有剩余的内容时，也不会出现。

``` ts

function fn(x: string | number) {

 if (typeof x === "string") {

 // do something

 } else if (typeof x === "number") {

 // do something else

 } else {

 x; // has type 'never'!

 }

}

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMMAKAHgLkQZygJxjAHNEAfRMEAWwCMBTfASkQG8BYAKEURmEVRQAngAd6cfukQBeWYgBEeQiXksO3HogD0WxABM4uONXpQAFkWJceAX0T0ANjnq9+g0eMky58qnUaqbNaaOvqGOMamFiT2TvTBdo7OQRo86ADc2rpmAIY4iMJiiADkYPQAbozFAIQJXDZAA)

函数 fn (x: string | number){ if (typeof x = = “ string”){///do something } else if (typeof x = = “ number”){//do something else } else { x;/has type‘ never’! } 试试


```

### [](#function)`Function

功能

The global type `Function` describes properties like `bind`, `call`, `apply`, and others present on all function values in JavaScript. It also has the special property that values of type `Function` can always be called; these calls return `any`:

全局类型 Function 描述了类似 bind、 call、 apply 等属性在 JavaScript 的所有函数值上的表现。它还有一个特殊属性，即 Function 类型的值总是可以被调用；这些调用返回任何:

``` ts

function doSomething(f: Function) {

 return f(1, 2, 3);

}

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFMAFyIBi408YAlIgN4CwAUIogE64jdJgJAIwAaRACZxAZgYBuDgF8gA)

(f: Function){ return f (1,2,3) ; } Try


```

This is an _untyped function call_ and is generally best avoided because of the unsafe `any` return type.

这是一个非类型化的函数调用，通常最好避免这种情况，因为任何返回类型都是不安全的。

If you need to accept an arbitrary function but don’t intend to call it, the type `() => void` is generally safer.

如果您需要接受一个任意函数，但不打算调用它，那么 type () => void 通常更安全。

[](#rest-parameters-and-arguments)Rest Parameters and Arguments

Rest 参数和参数


-----------------------------------------------------------------------------

> Background Reading:  
> [Rest Parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)  
> [Spread Syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)  
> 
> 背景阅读: Rest ParametersSpread Syntax

### [](#rest-parameters)Rest Parameters

休息参数

In addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an _unbounded_ number of arguments using _rest parameters_.

除了使用可选参数或重载使函数可以接受各种固定的参数计数，我们还可以定义使用 rest 参数接受无限个参数的函数。

A rest parameter appears after all other parameters, and uses the `...` syntax:

在所有其他参数之后会出现一个 rest 参数，它使用... 语法:

``` ts

function multiply(n: number, ...m: number[]) {

 return m.map((x) => n * x);

}

// 'a' gets value [10, 20, 30, 40]

const a = multiply(10, 1, 2, 3, 4);

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWxAG1gBzQTwBRgBciYIyARgKYBOANIgHRPLGkU0DaAugJSIDeAWABQiRNUpQQ1JMgbIAhpjx4AHnwC8APhKIAVInUBuEQF8RAeguIA5ApuIA5pIDOiAG4K0ISog4BGAAZ6ACZgxABmcIAWQK4RCAQXKEQFRA0UdCxcPCD6f1D6CPponiMgA)

Tsfunction multiply (n: number，... m: number []){ return m.map ((x) = > n * x) ; }//‘ a’gets value [10,20,30,40] const a = multiply (10,1,2,3,4) ; Try


```

In TypeScript, the type annotation on these parameters is implicitly `any[]` instead of `any`, and any type annotation given must be of the form `Array<T>`or `T[]`, or a tuple type (which we’ll learn about later).

在 TypeScript 中，这些参数上的类型注释隐式地是 any [] 而不是 any，并且给出的任何类型注释都必须是 Array < t> 或 t [] 这样的形式，或者是一个 tuple 类型 (我们将在后面学习)。

### [](#rest-arguments)Rest Arguments

休息的争论

Conversely, we can _provide_ a variable number of arguments from an array using the spread syntax. For example, the `push` method of arrays takes any number of arguments:

相反，我们可以使用 spread 语法从数组中提供可变数量的参数。例如，数组的 push 方法接受任意数量的参数:

``` ts

const arr1 = [1, 2, 3];

const arr2 = [4, 5, 6];

arr1.push(...arr2);

[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAhgJwQRhgXhgbWQGhgJjwGYBdAbgFgAoUSWRBfdLAFjwFY8A2c6h5AHQAHAK4QAFgAoBMhvgCUZIA)

1 = [1,2,3] ; const ar2 = [4,5,6] ; arr1.push (... arr2) ; Try


```

Note that in general, TypeScript does not assume that arrays are immutable. This can lead to some surprising behavior:

注意，一般来说，TypeScript 并不假定数组是不可变的，这会导致一些令人惊讶的行为:

``` ts

// Inferred type is number[] -- "an array with zero or more numbers",

// not specifically two numbers

const args = [8, 5];

const angle = Math.atan2(...args);

A spread argument must either have a tuple type or be passed to a rest parameter.2556A spread argument must either have a tuple type or be passed to a rest parameter.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMDYCwAoEUASQDsAzGaSAE1ABcBPAB0lAEtFRSBXAWwBGMANoBdUAFoJoAEQBDUqDmw5jUAHd29ABagAXjDigEoPgja9BMRDIA0BIqTj1QiVgGN25du7kAbPzV6dSNLISQCdzhSRBdlAHMuAF5QYQAOW1AMUQBuSOjYpVJ4vzYUgFk5HQA6KoU0AApq5oTEAEocoA)

Ts// 推断类型是 number [] -- “ a array with zero or more numbers”,//not specifically two numbersconst args = [8,5] ; const angle = Math.atan2 (... args) ; spread 参数必须具有 tuple 类型或被传递给 rest 参数。试试


```

The best fix for this situation depends a bit on your code, but in general a `const` context is the most straightforward solution:

对于这种情况，最好的解决办法有点取决于你的代码，但是一般来说，常量上下文是最直接的解决方案:

``` ts

// Inferred as 2-length tuple

const args = [8, 5] as const;

// OK

const angle = Math.atan2(...args);

[Try](https://www.typescriptlang.org/play/#code/PTAEEkDsDMFMCd6wCagIYGdQCYC0AbWSAcwBcALUUgVwAdCBYAKAGMB7SDU9eYrAXlABtABwAaUAFYAuuiztOpANzMQoAPIBpZgq7oShUIICyaCgDozaSNgAU5h2l4YAlEqA)

Ts// 推断为 2-length tupleconst args = [8,5] as const;//OKconst angle = Math.atan2 (... args) ; Try


```

Using rest arguments may require turning on [`downlevelIteration`](https://www.typescriptlang.org/tsconfig#downlevelIteration) when targeting older runtimes.

使用 rest 参数可能需要在针对旧的运行时打开 downlevelIteration。

[](#parameter-destructuring)Parameter Destructuring

参数析构


-----------------------------------------------------------

> Background Reading:  
> [Destructuring Assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)  
> 
> 背景阅读：破坏作业

You can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this:

可以使用参数析构化来方便地将作为参数提供的对象解压缩到函数体中的一个或多个局部变量中。在 JavaScript 中，它看起来像这样:

```


js

function sum({ a, b, c }) {

 console.log(a + b + c);

}

sum({ a: 10, b: 3, c: 9 });

{ a，b，c }){ console.log (a + b + c) ; } sum ({ a: 10，b: 3，c: 9}) ;


```

The type annotation for the object goes after the destructuring syntax:

对象的类型注释在析构化语法之后:

``` ts

function sum({ a, b, c }: { a: number; b: number; c: number }) {

 console.log(a + b + c);

}

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAZxAWwBQG9EEMA0iARoRIgL4BciOu1Y6RApgE4Dcx9jrHEXazFhQCUNALAAoRIggJkcADZMAdArgBzDLkQBqYrpnC2k8kA)

Tsfunction sum ({ a，b，c } : { a: number; b: number; c: number }){ console.log (a + b + c) ; } Try


```

This can look a bit verbose, but you can use a named type here as well:

这看起来有点冗长，但是你也可以在这里使用命名类型:

``` ts

// Same as prior example

type ABC = { a: number; b: number; c: number };

function sum({ a, b, c }: ABC) {

 console.log(a + b + c);

}

[Try](https://www.typescriptlang.org/play/#code/PTAEGUEMFsFNUgZ1ABwE4EsD2bSwB4woA2sAsAFAAuAnivAIIBCAwqALygDeCAXKADsArtABGsNAG5Qo-sLETpAYzkjxuAL6TKAMyEClVbANCIRACh6QANDNtLQG-sxYBKbpVCglWAYiykAHTEWADm5pCgANQy0d6u2hQaQA)

Ts// 与前面的示例类型 ABC = {a: number; b: number; c: number} ; 函数 sum ({ a，b，c } : ABC){ console.log (a + b + c) ; } Try


```

[](#assignability-of-functions)Assignability of Functions

函数的可转让性


--------------------------------------------------------------------

### [](#return-type-void)Return type `void

返回类型 void

The `void` return type for functions can produce some unusual, but expected behavior.

函数的 void 返回类型可以产生一些不寻常但是预期的行为。

Contextual typing with a return type of `void` does **not** force functions to **not** return something. Another way to say this is a contextual function type with a `void` return type (`type vf = () => void`), when implemented, can return _any_ other value, but it will be ignored.

返回类型为 void 的上下文类型不会强制函数不返回某些内容。另一种说法是，带有 void 返回类型 (type vf = () = > void) 的上下文函数类型在实现时可以返回任何其他值，但它将被忽略。

Thus, the following implementations of the type `() => void` are valid:

因此，type () => void 的下列实现是有效的:

``` ts

type voidFunc = () => void;

const f1: voidFunc = () => {

 return true;

};

const f2: voidFunc = () => true;

const f3: voidFunc = function () {

 return true;

};

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAbgFgAoerODAZ2CgDMBGALguXTY8hErnIBvelCgAnCMDQyMUYDLQRadAL6bGzNpwBMfeAMw58xMirUb6e1uw4BmE5UEXO54AmYioknTScgpKNuqaOkA)

2: voidFunc = () = > true; const f3: voidFunc = function (){ return true; } ; Try


```

And when the return value of one of these functions is assigned to another variable, it will retain the type of `void`:

当其中一个函数的返回值被赋给另一个变量时，它将保留 void 类型:

``` ts

const v1 = f1();

const v2 = f2();

const v3 = f3();

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAbgFgAoerODAZ2CgDMBGALguXTY8hErnIBvelCgAnCMDQyMUYDLQRadAL6bGzNpwBMfeAMw58xMirUb6e1uw4BmE5UEXO54AmYioknTScgpKNuqaOvQA9NFQALSJWGjAifEOBjBcwtzEunRMjrCGOYZ59gX67DDOOc55QA)

Tsconst v1 = f1() ; const v2 = f2() ; const v3 = f3() ; Try


```

This behavior exists so that the following code is valid even though `Array.prototype.push` returns a number and the `Array.prototype.forEach` method expects a function with a return type of `void`.

此行为的存在使得下面的代码即使在 Array.prototype.push 返回一个数字和一个 Array.prototype.forEach 方法期望返回类型为 void 的函数也是有效的。

``` ts

const src = [1, 2, 3];

const dst = [0];

src.forEach((el) => dst.push(el));

[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBBBOwYF4YG0CMAaGAmHAzALoDcAsAFCiSwAm0K6ADKZZQsAHQBmI8AogENgACwAUYgKYAbAJQoAfDHpROABwCuEcTNmySQA)

1,2,3] ; const dst = [0] ; src.forEach (((el) = > dst.push (el)) ; Try


```

There is one other special case to be aware of, when a literal function definition has a `void` return type, that function must **not** return anything.

还有另外一个需要注意的特殊情况，当文本函数定义具有 void 返回类型时，该函数不能返回任何内容。

``` ts

function f2(): void {

 // @ts-expect-error

 return true;

}

const f3 = function (): void {

 // @ts-expect-error

 return true;

};

[Try](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMATACgJQC5EDc4wAmiA3gLABQiiA9DYgAJQDOAtAKYAeADu9BwCcBcAZWoD2UEAKRQBIdgG5KAX0qUICZlGQBmRAF5k4aPCSYc+IqTG16TNl1792QkbYlSZiOQuUUVRSA)

Tsfunction f2() : void {//@ts-expect-error return true; } const f3 = function () : void {//@ts-expect-error return true; } ; Try


```

For more on `void` please refer to these other documentation entries:

关于 void 的更多信息，请参考其他文档条目:

*   [v1 handbook](https://www.typescriptlang.org/docs/handbook/basic-types.html#void)
*   [v2 handbook](https://www.typescriptlang.org/docs/handbook/2/functions.html#void)
*   [FAQ - “Why are functions returning non-void assignable to function returning void?”](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void)

V1 handbookv2 handbookFAQ-“为什么返回非空可分配函数的函数返回空？”