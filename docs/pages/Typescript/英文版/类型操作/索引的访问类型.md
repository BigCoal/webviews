# 索引的访问类型

> Using Type['a'] syntax to access a subset of a type.

We can use an _indexed access type_ to look up a specific property on another type:

我们可以使用一个_索引访问类型_来查询另一个类型上的特定属性:

```ts

type Person = { age: number; name: string; alive: boolean };

type Age = Person["age"];

 type Age = number

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUKEhQAgkUywEKVAG0ARIQi6AuvID0pqJYB6AfiA)


```

The indexing type is itself a type, so we can use unions, `keyof`, or other types entirely:

索引类型本身就是一个类型，所以我们可以完全使用unions、`keyof`或其他类型:

```ts

type I1 = Person["age" | "name"];

 type I1 = string | number

type I2 = Person[keyof Person];

 type I2 = string | number | boolean

type AliveOrName = "alive" | "name";

type I3 = Person[AliveOrName];

 type I3 = string | boolean

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUAHoFUALRqAxuWBqVc0JCgBJAIyZYCFKgDaAIkIQbUAD5QbqJg4C68pVD8A9AH45PXBoQwAmMzgkNCsAawgQZAAzc1jUb0VlAODQgwBBAWEAeXgAOQ8zO2KHZ1d3Zht5fXCAZmiLOKKhCDLK5izfXKA)


```

You’ll even see an error if you try to index a property that doesn’t exist:

如果你试图索引一个不存在的属性，你甚至会看到一个错误:

```ts

type I1 = Person["alve"];

Property 'alve' does not exist on type 'Person'.2339Property 'alve' does not exist on type 'Person'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAXATwAdJQAFGROAO1AF5QBvUAQwHNJUaBXAWwBGMANygarPl1CJ80AJY12o1gBs5ANykC4cFZFZ0AvsNwhQAWksBjHvkvmCJMgEkAjAwpVaAbQBEqzV8AXWEgA)


```

Another example of indexing with an arbitrary type is using `number` to get the type of an array’s elements. We can combine this with `typeof` to conveniently capture the element type of an array literal:

另一个使用任意类型进行索引的例子是使用`number`来获取数组元素的类型。我们可以把它和`typeof`结合起来，方便地获取一个数组字面的元素类型:

```ts

const MyArray = [

 { name: "Alice", age: 15 },

 { name: "Bob", age: 23 },

 { name: "Eve", age: 38 },

];

type Person = typeof MyArray[number];

 type Person = {
    name: string;
    age: number;
}

type Age = typeof MyArray[number]["age"];

 type Age = number

// Or

type Age2 = Person["age"];

 type Age2 = number

[Try](https://www.typescriptlang.org/play/#code/MYewdgzgLgBAsgTwIICcUEMEwLwwNoBQMMA3jGOgLYCmAXDAERIA2AlsNQwDQzoDmdGAEYArDAC+XIqXJVBDAEIgARt14D6AJgDMEqcTIUa9BgFEAbpx79B2gBx6CAXQDcBAlAQAHajAAK1CgQ4Dgwnj4gAGbwyGiYeGAArpTKga4EAPQZxDAAegD8Ht6+SAKh4dRRMagYCAnJqShOeAw2DOlZOQWZ2QDyKEU+MKXUmqEBQeAtbR3ZxAVAA)


```

You can only use types when indexing, meaning you can’t use a `const` to make a variable reference:

你只能在索引时使用类型，这意味着你不能使用`const`来做一个变量的引用:

```ts

const key = "age";

type Age = Person[key];

Type 'key' cannot be used as an index type.  
'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'?2538  
2749Type 'key' cannot be used as an index type.  
'key' refers to a value, but is being used as a type here. Did you mean 'typeof key'?`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMAOdB2AFgE4AoAFwE8AHSUABRkTgDtQBeUAb1AEMBzSKhYBXALYAjGAG5QLXmKGhE5aAEsW-WbwA2agG5KJcODsi82AX2mkQoALSOAxiPKP7pJ6xWgA1pEoOUAAiAUhgmypaUABBQSDGJFYAbX9KAF1pIA)


```

However, you can use a type alias for a similar style of refactor:

然而，你可以使用类型别名来实现类似的重构风格:

```ts

type key = "age";

type Age = Person[key];

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAChBOBnA9gOygXigbygQwHMIAuKVAVwFsAjBAbjL0pKkWHgEtUCG8AbDgDcW1ZMj4Q86AL50AUAHoFUALRqAxuWBqVc0JCgBrCCExQARIQjn5+6AEEiZuEjQBtYyAC6dIA)


```