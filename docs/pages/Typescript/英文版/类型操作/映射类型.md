# 映射类型
> Generating types by re-using an existing type.

When you don’t want to repeat yourself, sometimes a type needs to be based on another type.

当你不想重复自己的时候，有时候一种类型需要基于另一种类型。

Mapped types build on the syntax for index signatures, which are used to declare the types of properties which have not been declared ahead of time:

映射类型建立在索引签名的语法之上，索引签名用于声明未提前声明的属性类型:

```ts

type OnlyBoolsAndHorses = {

 [key: string]: boolean | Horse;

};

const conforms: OnlyBoolsAndHorses = {

 del: true,

 rodney: false,

};

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAEg9gJwM7QLxQN4F8DcAoAegKgFoyBjAV2DJL1EigHkA7AGxACE442kBBFgBN4yCEijoMeKFADaAawggAXFCTAEASxYBzALpqARjzYQAhiygAfWIhT5cePOTgsNUVywBmiALZIaqwc3LwCwqIoElIyUEIQbGqalBAANLEIcEIsymre5nxpeLhAA)

1.1.1.1.2.2.2.2.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.4.3.3.3.3.4.3.3.3.3.3.3.3.3.3.3.3.4.3.3.3.3.3.3.3.3.3.3.3.3.4.3.3.3.3.3.3.3.4.3.3.3.3.4.3.3.3.3.4.3.3.3.3.3.3.3.4.3.3.3.3.3.3.3.3


```

A mapped type is a generic type which uses a union of `PropertyKey`s (frequently created [via a `keyof`](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)) to iterate through keys to create a type:

映射类型是一种泛型类型，它使用 PropertyKeys (通常通过 keyof 创建) 的联合来迭代键以创建类型:

```ts

type OptionsFlags<Type> = {

 [Property in keyof Type]: boolean;

};

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA8mwEsD2A7AzgMQDYEMDmaAPACrgQB8UAvFAN4BQUUA2gAoBOSk7oUCKUANYQQSAGZRSkALoAuKACMkSLBBwoA3PQC+GoA)

{[ Property in keyof Type ] : boolean; } ; Try


```

In this example, `OptionsFlags` will take all the properties from the type `Type` and change their values to be a boolean.

在本例中，OptionsFlags 将获取 Type 类型中的所有属性，并将其值更改为布尔值。

```ts

type FeatureFlags = {

 darkMode: () => void;

 newUserProfile: () => void;

};

type FeatureOptions = OptionsFlags<FeatureFlags>;

 type FeatureOptions = {
    darkMode: boolean;
    newUserProfile: boolean;
}

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA8mwEsD2A7AzgMQDYEMDmaAPACrgQB8UAvFAN4BQUUA2gAoBOSk7oUCKUANYQQSAGZRSkALoAuKACMkSLBBwoA3PQC+WgPR6oAWhMBjAK7ATR+qEhQMa4OfYRs+NNTqMoAExzsggCySL4Q8gAUAJTUlABuSAi+WkwoEADuAKpoEOwc4giqkTFU8YnJOlq2ZA5OLhBwiKieNI3I6O4EhI44zq6daOT6hkwAegD8QA)

1.2.2.2.2.2.2.2.2.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3.3


```

### [](#mapping-modifiers)Mapping Modifiers

映射修饰符

There are two additional modifiers which can be applied during mapping: `readonly` and `?` which affect mutability and optionality respectively.

在映射过程中可以使用两个额外的修饰符: readonly 和？，它们分别影响可变性和可选性。

You can remove or add these modifiers by prefixing with `-` or `+`. If you don’t add a prefix, then `+` is assumed.

您可以通过使用 - 或 + 作为前缀来删除或添加这些修饰符。如果您没有添加前缀，则假定为 + 。

```ts

// Removes 'readonly' attributes from a type's properties

type CreateMutable<Type> = {

 -readonly [Property in keyof Type]: Type[Property];

};

type LockedAccount = {

 readonly id: string;

 readonly name: string;

};

type UnlockedAccount = CreateMutable<LockedAccount>;

 type UnlockedAccount = {
    id: string;
    name: string;
}

[Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdIGdQHIBOkCGATWA7AGwE9VQsAXC9ASwCMBXC5UAM3VmnNAuIAdIqFHw4D0FGsgBQvAaADCmSpACyTLHUKQAPABV+kAHygAvKADeU0KAC0SvEWKgA2gAVRkcU5r5QAa0hiWFZQfQEAXQAuUIM3Dy9wgG4pAF9kmQNQABlYAGMAnABBXNzYBnwKUwsrUHsCElAaHGikah8Ac2TrOsdQfCxoSBa2-E7U9NlIUABVIjyC4tLyyrNFbGY1Cg0tbRz8yCKSsorDZJBrUAA9AH4gA)

Ts// 从类型的属性值 CreateMutable  ; 键入 UnlockedAccount = { id: string; } Try


```

```ts

// Removes 'optional' attributes from a type's properties

type Concrete<Type> = {

 [Property in keyof Type]-?: Type[Property];

};

type MaybeUser = {

 id: string;

 name?: string;

 age?: number;

};

type User = Concrete<MaybeUser>;

 type User = {
    id: string;
    name: string;
    age: number;
}

[Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdIGdQHJYAcAuBLWA7AQwBtVRCssAnHAIwFctlQAzK2ac0LATw0lQoM7flVzIAUL36gAwgQDGVSEwA8AFT6QAfKAC8oAN4TQoANoAFEZDE9QOfKADWkHrBahN-ALoBaAPwAXJ5alta23gDcEgC+0VJaoACyhDy0kACqSDb6Rib2ACbBSNQOAObRpkTQkEGgJTT4FfmEZbXB+PTQ6VTRcRIJMlk5BvL4SiqQqilpmdlU2tEgpqAAev5AA)

Ts// 从类型的属性 Concrete  = {[ Property in keyof Type ]-？: Type [ Property ] ; } ; 类型 MaybeUser = { id: string; name？字符串；年龄？类型 User = Concrete < maybeuser > ; type User = { id: string; name: string; age: number; } Try


```

[](#key-remapping-via-as)Key Remapping via `as

密钥重映射通过


----------------------------------------------------------

In TypeScript 4.1 and onwards, you can re-map keys in mapped types with an `as` clause in a mapped type:

在 TypeScript 4.1 及以后的版本中，您可以使用映射类型中的 as 子句重新映射映射类型中的键:

```ts

type MappedTypeWithNewProperties<Type> = {

 [Properties in keyof Type as NewKeyType]: Type[Properties]

}

Tstype MappedTypeWithNewProperties < Type > = {[[ Properties in keyof Type as NewKeyType ] : Type [ Properties ]}


```

You can leverage features like [template literal types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html) to create new property names from prior ones:

你可以利用一些特性，比如模板文字类型，从以前的属性中创建新的属性名:

```ts

type Getters<Type> = {

 ``[Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]``

};

interface Person {

 name: string;

 age: number;

 location: string;

}

type LazyPerson = Getters<Person>;

 type LazyPerson = {
    getName: () => string;
    getAge: () => number;
    getLocation: () => string;
}

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4hzAgJwM4B4Aq4ID4oF4oBvAKCnKgG0AFJAe0iVCgEsA7KAawhDoDMoWSFACGKKAAMA5vAAkRAMIiwLYCIA2LAF4Q0KYEnZSoAMii0GyUDgC+EgLoAuKAAoAlATxCINeo1D2JDYA3CQk7IhIfCIAxtDUyCh0HKQUUGwiALYQzvqGbFKhaSIyzmwArpkARshFFOp0MSLALMm5BkahNmGgwgAyIlogCajJBLDwkegjSWw4oQD0CxQAegD8QA)

类型为‘ get ${Capitalize < string & Property> }‘] : () = > Type [ Property ]} ; 接口 Person { name: string; age: number; location: string; } Type LazyPerson = Getters < Person > ; Type LazyPerson = { getName: () = > string; getAge: () = > number; getLocation: > string: 尝试


```

You can filter out keys by producing `never` via a conditional type:

你可以通过一个条件类型生成 never 来过滤掉键:

```ts

// Remove the 'kind' property

type RemoveKindField<Type> = {

 [Property in keyof Type as Exclude<Property, "kind">]: Type[Property]

};

interface Circle {

 kind: "circle";

 radius: number;

}

type KindlessCircle = RemoveKindField<Circle>;

 type KindlessCircle = {
    radius: number;
}

[Try](https://www.typescriptlang.org/play/#code/PTAECUFMFsHsDdKgC4AskHIDWBLAdgCYagAOATrCZGcgJ4BQdVEMCkA0vgQGI6QA2BADwAVWlQB8oALygA3vVBLQAbQAKFKjVqh8oLJFqwAZqDHMAhgGdQAUQAeAY34BXApCEbK1OgBpQAES4hAESALoAXGbikOqaPrRh9AC+ANz09PjI1MYWjkgAwjhkzkgKyvpcUQGOxaUB6RVkFgQ4LlZReC7QAEbU6ckZTEichPyQVlZFJeMyLHCIozx8gkLTpRLpIMoAegD8QA)

Ts///Remove‘ kind’Property/Type RemoveKindField < Type > = {[ Property in keyof Type as Exclude < Property，“ kind”> ] : Type [ Property ]} ; interface Circle { kind: “ Circle”; radius: number; } Type KindlessCircle = RemoveKindField < Circle > ; Type KindlessCircle = { radius: number; } Try


```

You can map over arbitrary unions, not just unions of `string | number | symbol`, but unions of any type:

你可以映射任意的联合，不仅仅是字符串 | 数字 | 符号的联合，而是任意类型的联合:

```ts

type EventConfig<Events extends { kind: string }> = {

 [E in Events as E["kind"]]: (event: E) => void;

}

type SquareEvent = { kind: "square", x: number, y: number };

type CircleEvent = { kind: "circle", radius: number };

type Config = EventConfig<SquareEvent | CircleEvent>

 type Config = {
    square: (event: SquareEvent) => void;
    circle: (event: CircleEvent) => void;
}

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogbhAdsAwge0QMwJYHMA88SwAzlBAB7BIAmZA3lANbaI0BcUJwATq7lAC+APigBeKPQBQUWVADaMKK1gJkZAIZkY8gEQs2ugLpHOACghrgnGAEpxouGmw0A3FMFSpoSFADKAI4Arho8EETI4pLMrBxQuiTBoRC6ADRQFJyIQQC2AEYQPOkgWbkFPELuPtAo2DwAxgA24VZRjAZxuvV1TSnpPBo02EEkpfmFlV7VUOhYeFERqBg4BIEhYYtQAD4zPc2LwlIA9EdyAHoA-EA)

Tstype EventConfig < Events extends { kind: string } > = {[ e in Events as e [“ kind”]] : (event: e) = > void; } type SquareEvent = { kind: “ square”，x: number，y: number } ; type CircleEvent = { kind: “ circle”，radius: number } ; type Config = EventConfig < event | CircleEvent > type = { square: (event: squarevent) = > void; circle: (event: CircleEvent) = > void; } Try;


```

### [](#further-exploration)Further Exploration

进一步探索

Mapped types work well with other features in this type manipulation section, for example here is [a mapped type using a conditional type](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) which returns either a `true` or `false` depending on whether an object has the property `pii` set to the literal `true`:

在这个类型操作部分，映射类型可以很好地与其他特性一起工作，例如，这里是一个使用条件类型的映射类型，根据对象的属性 pii 是否设置为文字 true，返回 true 或 false:

```ts

type ExtractPII<Type> = {

 [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;

};

type DBFields = {

 id: { format: "incrementing" };

 name: { type: string; pii: true };

};

type ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;

 type ObjectsNeedingGDPRDeletion = {
    id: false;
    name: true;
}

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogHsATgQwMbAAoEksB4Aq4EAfFALxQDeAUFFANoaID2kioUAlgHZQDWEEMwBmUQpAC6ALjFFGLNqAlQICCNwAmAZypQwnTjKQBXaAF8oAfignoM4cgA2WiAG5qZ99VCQoAEQAhADFOCEdtcipaLg0ZSihhZkQAW2RgGQAiHlRECGT1YB4AcwyoT2juZHy4myIZLSRi1z0DI0RTMvdy7yIoAHkAIwArCHQtADkICA1igHE-DAAlPzCIQuZeCngkNEwcXECQsO1idwB6M7ooAD1LIA)

Tstype ExtractPII  = {[ Property in keyof Type ] : Type [ Property ] extends { pii: true } ？类型: ObjectsNeedingGDPRDeletion = ExtractPII < DBFields > ; 类型: ObjectsNeedingGDPRDeletion = { id: false; name: true; } Try


```