# 模板文字类型
> Generating mapping types which change properties via template literal strings.

Template literal types build on [string literal types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types), and have the ability to expand into many strings via unions.

模板文字类型建立在字符串文字类型之上，并且能够通过联合扩展成许多字符串。

They have the same syntax as [template literal strings in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals), but are used in type positions. When used with concrete literal types, a template literal produces a new string literal type by concatenating the contents.

它们与 JavaScript 中的模板字符串具有相同的语法，但是用于类型位置。当与具体文本类型一起使用时，模板文本通过连接内容生成一个新的字符串文本类型。

```ts

type World = "world";

``type Greeting = `hello ${World}`;``

 type Greeting = "hello world"

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA6g9gJwDYBMoF4oCIDujVYDcAUMaJFAOIIQTACWAdgOYZQAGAFhEknFABIA3vGQoAvuxIB6aVHkA9APxA)

Tstype World = “ World”; type Greeting = ‘ hello ${ World }‘ ; type Greeting = “ hello World”Try


```

When a union is used in the interpolated position, the type is the set of every possible string literal that could be represented by each union member:

当在插值位置使用联合时，类型是每个联合成员可以表示的每个可能的字符串文字的集合:

```ts

type EmailLocaleIDs = "welcome_email" | "email_heading";

type FooterLocaleIDs = "footer_title" | "footer_sendoff";

``type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;``

 type AllLocaleIDs = "welcome_email_id" | "email_heading_id" | "footer_title_id" | "footer_sendoff_id"

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogtgQwJYBsAyB7AxglECSAIgM5QC8UARAO4QpYZwQD6EiqlUAPlW8iswAWEBABMkAOwDmlANwAoUJCgAxDBmAQATphx4ipCpQBm6zVubAkwPJx4mz25sQgTRGY8bnzF4aAEEUdGxcAhJyKAADABIAb3h+XVCDblVHHRD9EgBfZiRRSIUAeiKoMoA9AH4gA)

键入 “欢迎电子邮件”| “ email 标题”| “ FooterLocaleIDs”= “ footer _ title”| “ footer _ sendoff”; 键入 “ AllLocaleIDs”= “ ${ EmailLocaleIDs | FooterLocaleIDs } _ id”; 键入 “ AllLocaleIDs”= “ welcome _ email _ id”| “ email _ heading _ id”| “ footer _ heading _ id _ id”| “ footer _ title _ id”| “ footer _ doff _ footer _ footer _ footer _ footer _ footer _ footer‘ Try”


```

For each interpolated position in the template literal, the unions are cross multiplied:

对于模板文字中的每个插值位置，联合是十字乘:

```ts

``type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;``

type Lang = "en" | "ja" | "pt";

``type LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;``

 type LocaleMessageIDs = "en_welcome_email_id" | "en_email_heading_id" | "en_footer_title_id" | "en_footer_sendoff_id" | "ja_welcome_email_id" | "ja_email_heading_id" | "ja_footer_title_id" | "ja_footer_sendoff_id" | "pt_welcome_email_id" | "pt_email_heading_id" | "pt_footer_title_id" | "pt_footer_sendoff_id"

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAogtgQwJYBsAyB7AxglECSAIgM5QC8UARAO4QpYZwQD6EiqlUAPlW8iswAWEBABMkAOwDmlANwAoUJCgAxDBmAQATphx4ipCpQBm6zVubAkwPJx4mz25sQgTRGY8bnyA9D6gAtEFYAK7AQQGK4NAAgijo2LgEJORQAAYAJADe8Py6SQbcqo46ifokAL7MSKJpCkrQaAjSqZSudlQAVggdlGDA3lHK+XgAshDExAhSyYbp2U3SVdlxCXqzFXW+-lBQAHoA-EA)

‘ ${EmailLocaleIDs | FooterLocaleIDs} _ id‘ ; type Lang = “ en”| “ ja”| “ pt”; 键入 LocaleMessageIDs = ‘ ${ Lang } _ ${ AllLocaleIDs }‘ ; 键入 LocaleMessageIDs = “ en _ welcome _ email _ id”| “ en _ email _ heading _ id”| “ en _ footer _ title _ id”| “ en _ footer _ sendoff _ id”| “欢迎来电”| ” 邮件标题 id”| “ ja _ footer _ title _ id”| “ ja _ footer sendoff _ id”| “ pt _ welcome _ email _ id”| “ pt _ email _ heading _ id”“ pt _ footer _ title _ id”| “ pt _ footer _ sendoff _ id”“ Try


```

We generally recommend that people use ahead-of-time generation for large string unions, but this is useful in smaller cases.

我们通常建议人们对大型字符串联合使用提前生成，但这在小型情况下很有用。

### [](#string-unions-in-types)String Unions in Types

类型字符串联合

The power in template literals comes when defining a new string based off an existing string inside a type.

当基于类型中的现有字符串定义新字符串时，模板字符的威力就来了。

For example, a common pattern in JavaScript is to extend an object based on the fields that it currently has. We’ll provide a type definition for a function which adds support for an `on` function which lets you know when a value has changed:

例如，JavaScript 中的一个常见模式是基于对象当前拥有的字段扩展对象。我们将为一个函数提供一个类型定义，该函数增加了对 on 函数的支持，可以让你知道一个值什么时候发生了变化:

```ts

const person = makeWatchedObject({

 firstName: "Saoirse",

 lastName: "Ronan",

 age: 26,

});

person.on("firstNameChanged", (newValue) => {

 ``console.log(`firstName was changed to ${newValue}!`);``

});

[Try](https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFABMCmBjANgIbxagBmArpDgC4CW0koAtgQNZYDqB1OAFlhgDyAIwBWuagApoYgFygCkAJ4BKeYqUBuNCFABaAznLUDetDgYpqoAA5ZUDUAF5mbTtz4CR4mpIDeaKBktKjUAHIETFjyAEQAygTQIShYMQA0gaCEVhFRsQBKDIrpmQQA5tGgAEwAbBkAviraaHYOkAB0DJIxpMnhkVgAwryKFRjpoJKQWADuAGoEeORYKs4AfKABQRaQKNB4WO140GWSAAa9obkkMwQooHyjAqDU0KAAJH7T84vL9QCEZyaaEamiAA)

({firstName: “ Saoirse”，lastName: “ Ronan”，age: 26，}) ; person.on (“ firstnamecchanged”，(newValue) = > { console.log (‘ firstName 更改为 ${ newValue } ！试试看


```

Notice that `on` listens on the event `"firstNameChanged"`, not just `"firstName"`, template literals provide a way to handle this sort of string manipulation inside the type system:

注意，在监听事件 “firstNameChanged” 时，不仅仅是 “ firstName”，模板文本提供了一种在类型系统中处理这种类型的字符串操作的方法:

```ts

type PropEventSource<Type> = {

 ``on(eventName: `${string & keyof Type}Changed`, callback: (newValue: any) => void): void;``

};

/// Create a "watched object" with an 'on' method

/// so that you can watch for changes to properties.

declare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgTgezAUQG4QHbAMoIK5wDGEAPACrgQB8UAvFAN4BQUrUCGAFBOlgHIBDALYQAXFAAGAEgYBnYHACWGAOZQAZFADWEEAgBmUCpAC+AYQAWA1RAAmEgDRRCAgDauARgMJbxnDBAA7gBqbnhiUNYgAJR0NKgIirbR4glJANxMJplMAPT5UGZwEALA0AJQAESBpYQWduweAFYQhMCVUIGKwBaRGFAA5BwDUCI9CLZ5BbIIUD2lUHp4ztadtb36CHDOVjayc7NgiJBwwIoQsgB0TLatrgLFUPp4GG2KHKMCOgDq63YA8s1WsByJQqJwEM1xMYICkjJQNLBjmhMDh8ERSDCqOkgA)

{on (eventName: ‘ ${ string & keyof Type} Changed’，callback: (newValue: any) = > void; } ;/// 创建一个带有‘ on’方法 /// 的 “ watched object”，这样您就可以查看对 properties.declarate 函数 makechebject < Type > (obj: Type) : Type & propetsource < Type > ; Try


```

With this, we can build something that errors when given the wrong property:

有了这个，我们就可以构建一些在给出错误属性时会出错的东西:

```ts

const person = makeWatchedObject({

 firstName: "Saoirse",

 lastName: "Ronan",

 age: 26

});

person.on("firstNameChanged", () => {});

// Prevent easy human error (using the key instead of the event name)

person.on("firstName", () => {});

Argument of type '"firstName"' is not assignable to parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.2345Argument of type '"firstName"' is not assignable to parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.

// It's typo-resistant

person.on("frstNameChanged", () => {});

Argument of type '"frstNameChanged"' is not assignable to parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.2345Argument of type '"frstNameChanged"' is not assignable to parameter of type '"firstNameChanged" | "lastNameChanged" | "ageChanged"'.`[Try](https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAC4CeADpKAArwkCiAbpAHYEDKcArtAMaQA8AKqUgA+UAF5QAbzyhZoOIwAUkBswByAQwC2kVAAMAJJMQFoAS0YBzUADJQAa0hE4AM1CCyAXwDCACw1WkAAmegA0oFwaADZRAEYaXPaoioyQAO4AatHsuqABRACU4qJ0cGZBBail5QDceJ51eEGQXFEa0OQu7IxcBGYKoFoajgDqGgRcvsEA8rEAVi0EAsKKcPOo-JXutpTU9EysHNx8-MJ1IKAAtNdc7ATXl3hcCiagZEgDEkOj45Mz84tFNJZC4zEgCJodKgAEQsDRlJCQaGhGSgNomSG5aEAJQUAWRqI0llyaAAbPUCo13ogFAA6BSKaGg8GYvwBYlBZGgRRFMSiSSeSl4PAXKgqA6gSAaRBEUC+dhDRiS2AIbnsRAWawEKYOJygCwmKVBeRubXkcXMUCMbSQAp4al0hlMsEYm1cnnFKSCxoXACSBAA5IhQMQSHBLh0NSYAgR7TAaYx6UomSybWzApzwh6+V7KUA)

({firstName: “ Saoirse”，lastName: “ Ronan”，age: 26}) ; person。对 (“ firstNameChanged”，() = > {}) ;// 防止人为的简单错误 (使用 key 而不是事件名称)。对 (“ firstName”，() = > {}) ; 类型 “ firstName” 的参数不能分配给类型 “ firstNameChanged”| 的参数 “ lastnamecchanged”| ” 年龄增长”。2345 类型 “ firstName” 的参数不能分配给类型 “ firstnamecchanged” 的参数 | “ lastnamecchanged”| ” 年龄增长”。// 是打错字的人。On (“ frstNameChanged”，() = > {} ; 类型 “ frstNameChanged” 的参数不能分配给类型 “ firstNameChanged”| “ lastNameChanged”| “ agecchanged”’. 2345 类型 “ frstNameChanged” 的参数不能分配给类型 “ firstNameChanged”| “ lastNameChanged”| “ lastagecchanged”’。试试


```

### [](#inference-with-template-literals)Inference with Template Literals

使用模板文字进行推理

Note how the last examples did not re-use the type of the original value. The callback used an `any`. Template literal types can infer from substitution positions.

请注意最后的示例如何没有重用原始值的类型。回调函数使用了 any。模板文字类型可以从替换位置推断。

We can make our last example generic to infer from parts of the `eventName` string to figure out the associated property.

我们可以使我们的最后一个示例成为泛型，从 eventName 字符串的各个部分推断出关联的属性。

```ts

type PropEventSource<Type> = {

 on<Key extends string & keyof Type>

 ``(eventName: `${Key}Changed`, callback: (newValue: Type[Key]) => void ): void;``

};

declare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;

const person = makeWatchedObject({

 firstName: "Saoirse",

 lastName: "Ronan",

 age: 26

});

person.on("firstNameChanged", newName => {

 (parameter) newName: string

 ``console.log(`new name is ${newName.toUpperCase()}`);``

});

person.on("ageChanged", newAge => {

 (parameter) newAge: number

 if (newAge < 0) {

 console.warn("warning! negative age");

 }

})

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBACgTgezAUQG4QHbAMoIK5wDGEAPACrgQB8UAvFAN4BQUrUCGJA0hCFBAA9gmACYBnKGOBwAlhgDmUAGRQA1rwQAzKBUhUWbQwAoI6LADkAhgFsIALigADACQMeIAL4BhABaWFECKOADRQhJYANhEARpaEqg5GGBAA7gBqkXj2OpQA2u4AugCUdDSoCDIiUEUO5ZUA3EwejUwiEIQRlnDQmngYhMAyHFDWluoA6pbAhD6BAPLRAFbtwOSUVEYISw66EDU5kMqwiChmOPhEpLtULYQcUlCQcGLD9KMTUzPzSytGzKyaGTPYBWWwOABE2EsFWeEHBwQMnSkoOy4IAShx-PCDJZ5NkAEwANiaRRaTxeGAAdBwjODAcCUb5-HiRPCoMkUijSowDKwAPR8wxC4Ui1gAPQA-LywvcEBEIJSIgh5EZHBz2TZoDIJK4OSjKcAEABVMBPLyWMQQIxFDyOUkkskQZ4cakYWm4iBMgKs0IcgCCeO5-zYAtFYagkulMm0SVSAegJCgAAYSsHhXcMC95ZSUl03eDc3AMHJ5ABCdkQeRTGToKAe8H2wweElAA)

{on < Key extends string & keyof Type> (eventName: ‘ ${ Key } Changed’，callback: (newValu)(eventName: ‘ ${ Key } Changed’，callback: (newValue: Type [ Key ]) = > void; } ; declare function makeWatchedObject < Type > (obj: Type) : Type & propetsource < Type > ; const person = makeWatchedObject ({ firstName: “ Saoirse”，lastName: “ Ronan”，age: 26}) ; person。在 (“ firstNameChanged” 上，newName = > {(parameter) newName: string console。日志 (‘ new name is ${ newName。的；; person。(“ agecchanged”，newAge = > {(参数) newAge: number if (newAge < 0))(newAge < 0){控制台。警告 (警告！消极年龄”) ; }) 尝试


```

Here we made `on` into a generic method.

在这里，我们进入了一个通用方法。

When a user calls with the string `"firstNameChanged'`, TypeScript will try to infer the right type for `Key`. To do that, it will match `Key` against the content prior to `"Changed"` and infer the string `"firstName"`. Once TypeScript figures that out, the `on` method can fetch the type of `firstName` on the original object, which is `string` in this case. Similarly, when called with `"ageChanged"`, TypeScript finds the type for the property `age` which is `number`.

当用户使用字符串 “firstnamecchanged” 调用时，TypeScript 将尝试推断 Key 的正确类型。为此，它将键与 “ Changed” 之前的内容进行匹配，并推断字符串 “ firstName”。一旦 TypeScript 发现了这一点，on 方法就可以获取原始对象的 firstName 类型，在本例中是 string。类似地，当使用 “ agecchanged” 调用时，TypeScript 会查找属性年龄的类型，即 number。

Inference can be combined in different ways, often to deconstruct strings, and reconstruct them in different ways.

推理可以以不同的方式组合，通常用于解构字符串，并以不同的方式重构它们。

[](#intrinsic-string-manipulation-types)Intrinsic String Manipulation Types

内部字符串操作类型


----------------------------------------------------------------------------------------

To help with string manipulation, TypeScript includes a set of types which can be used in string manipulation. These types come built-in to the compiler for performance and can’t be found in the `.d.ts` files included with TypeScript.

为了帮助进行字符串操作，TypeScript 包含了一组可用于字符串操作的类型。这些类型是编译器内置的，用于提高性能，在。打字稿中包含的 d.ts 文件。

### [](#uppercasestringtype)`Uppercase<StringType>

大写

Converts each character in the string to the uppercase version.

将字符串中的每个字符转换为大写版本。

##### [](#example)Example

```ts

type Greeting = "Hello, world"

type ShoutyGreeting = Uppercase<Greeting>

 type ShoutyGreeting = "HELLO, WORLD"

``type ASCIICacheKey<Str extends string> = `ID-${Uppercase<Str>}` ``

type MainID = ASCIICacheKey<"my_app">

 type MainID = "ID-MY_APP"

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwCWA7A5lAvFARACQgBsiB7AGigHdS4iATXAKFEigGUALUgV1HkQoM2KAFUwkOAGMAhgGcIAHgFI06AHxMA9Fqh6AegH4mLcNACC7AMIBJG1ZlTOEANIQQi9sDhQIAD2AIVHo5KDlvNXURAAMbABEAWgASAG9xSVkFT291AF9o0zYAWRk0eJFLW3tHZzcPXABbEAB9GQlcTR09KCMgA)

Tstype Greeting = “HELLO，WORLD” 类型 ShoutyGreeting = 大写 < Greeting > 类型 ShoutyGreeting = “ HELLO，WORLD” 类型 ascicachekey < < str extends string > = ‘ ID-${ Uppercase < str > }‘ type MainID = ascicachekey < “ my _ app”> 类型 MainID = “ ID-my _ app” Try


```

### [](#lowercasestringtype)`Lowercase<StringType>

小写字母

Converts each character in the string to the lowercase equivalent.

将字符串中的每个字符转换为等效的小写形式。

##### [](#example-1)Example

```ts

type Greeting = "Hello, world"

type QuietGreeting = Lowercase<Greeting>

 type QuietGreeting = "hello, world"

``type ASCIICacheKey<Str extends string> = `id-${Lowercase<Str>}` ``

type MainID = ASCIICacheKey<"MY_APP">

 type MainID = "id-my_app"

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwCWA7A5lAvFARACQgBsiB7AGigHdS4iATXAKFEigEUBXZJeRFDNigAZUlQhwAxgEMAzhAA8fJGnQA+JgHpNUXQD0A-ExbhoAQQDKAYQCSNq9MkALCAGkIIBReBwoEAB7AEKj0slCyPqpqQgAGyPQAtAAkAN6i4lJyit5wagC+MSZsALLSaDYAIkKWtvaOLu6euMUAmgD6ZgAKnbga2rpQhkA)

Tstype Greeting = “Hello，world”type QuietGreeting = Lowercase < Greeting > type QuietGreeting = “ Hello，world” 类型 ascii achekey  = ‘ id-${ Lowercase < str > }‘ type MainID = ascii achekey < “ MY _ app”> type MainID = “ id-MY _ app” Try


```

### [](#capitalizestringtype)`Capitalize<StringType>

大写

Converts the first character in the string to an uppercase equivalent.

将字符串中的第一个字符转换为等效的大写字母。

##### [](#example-2)Example

```ts

type LowercaseGreeting = "hello, world";

type Greeting = Capitalize<LowercaseGreeting>;

 type Greeting = "Hello, world"

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAMg9gdwgJwMYEMDOEDiyITACWAdgOZQC8UARABYQA2jcANFAnMowCY0DcAKFCQoeAsXJUoAYXRgiwdIyIAvCAB54SNFlz5CpMgD4hAejNQrAPQD8QA)

输入 Greeting = “Hello，world”; 输入 Greeting = 大写 < LowercaseGreeting > ; 输入 Greeting = “ Hello，world”Try


```

### [](#uncapitalizestringtype)`Uncapitalize<StringType>

取消大写

Converts the first character in the string to a lowercase equivalent.

将字符串中的第一个字符转换为等效的小写形式。

##### [](#example-3)Example

例子

```ts

type UppercaseGreeting = "HELLO WORLD";

type UncomfortableGreeting = Uncapitalize<UppercaseGreeting>;

 type UncomfortableGreeting = "hELLO WORLD"

[Try](https://www.typescriptlang.org/play/#code/C4TwDgpgBAqmkCcDGBDAzhA4giFgEsA7AcygF4oAiACQFEAZegeSgHUmAlegEUoG4AUKEixCSAPYBbAGbiEwFACMANlhx4ipCjDEow+BcvwAvCAB44iVBmy4CJAHyCA9M6juAegH4gA)

输入 uncomfortable greeting = Uncapitalize  ; 输入 uncomfortable greeting = “ HELLO WORLD” Try


```

Technical details on the intrinsic string manipulation types

The code, as of TypeScript 4.1, for these intrinsic functions uses the JavaScript string runtime functions directly for manipulation and are not locale aware.

`

```
function applyStringMapping(symbol: Symbol, str: string) {
    switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {
        case IntrinsicTypeKind.Uppercase: return str.toUpperCase();
        case IntrinsicTypeKind.Lowercase: return str.toLowerCase();
        case IntrinsicTypeKind.Capitalize: return str.charAt(0).toUpperCase() + str.slice(1);
        case IntrinsicTypeKind.Uncapitalize: return str.charAt(0).toLowerCase() + str.slice(1);
    }
    return str;
}
```

`

关于内部字符串操作类型的技术细节